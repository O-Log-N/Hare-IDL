@@--------   COMMON FUNCTIONS   --------

@@BEGIN-FUNCTION NAME="FUNCTION-GET-REF-TO-MEMBER-PROTO" PARAM-STRUCT-NAME PARAM-MEMBER
@@ASSERT IS-MEMBER(PARAM-MEMBER)
@@LET LOCAL-IS-PARENT = PARAM-MEMBER.GET-MAPPING-ANNOTATION( "PARENT" )
@@IF LOCAL-IS-PARENT.HAS-VALUE()
   @@RETURN "@PARAM-STRUCT-NAME@.__parent()"
@@ENDIF
   @@RETURN "@PARAM-STRUCT-NAME@.@PARAM-MEMBER.MAPPING-MEMBER-NAME().CAMEL-CASE-TO-LOWER-UNDERSCORE()@()"
@@END-FUNCTION NAME="FUNCTION-GET-REF-TO-MEMBER-PROTO"

@@--------   PRINT   --------


@@BEGIN-TEMPLATE NAME="PRINT-GENERATE-DECLARATIONS"
@@ASSERT IS-ROOT(PARAM-ROOT)
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-STRUCTS()
     @@INCLUDE TEMPLATE="PRINT-DECLARE-FN-ONLY" PARAM-NAME=LOCAL-PS-IT.STRUCT-NAME() PARAM-MAPPING-NAME=LOCAL-PS-IT.MAPPING-STRUCT-NAME()
  @@FOR-EACH END
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-DISCRIMINATED-UNIONS()
     @@INCLUDE TEMPLATE="PRINT-DECLARE-FN-ONLY" PARAM-NAME=LOCAL-PS-IT.STRUCT-NAME() PARAM-MAPPING-NAME=LOCAL-PS-IT.MAPPING-STRUCT-NAME()
  @@FOR-EACH END
@@END-TEMPLATE NAME="PRINT-GENERATE-DECLARATIONS"

@@BEGIN-TEMPLATE NAME="PRINT-DECLARE-FN-ONLY"
void dbgPrint@PARAM-NAME@( const @PARAM-MAPPING-NAME@& s, std::ostream& o, size_t offset );
@@END-TEMPLATE NAME="PRINT-DECLARE-FN-ONLY"


@@BEGIN-TEMPLATE NAME="PRINT-GENERATE-IMPLEMENTATIONS"
@@ASSERT IS-ROOT(PARAM-ROOT)
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-STRUCTS()
     @@INCLUDE TEMPLATE="PRINT-STRUCT" PARAM-STRUCT=LOCAL-PS-IT
  @@FOR-EACH END

  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-DISCRIMINATED-UNIONS()
    @@IF LOCAL-PS-IT.GET-MAPPING-ANNOTATION( "OWNING-PTR" ).HAS-VALUE()
      @@INCLUDE TEMPLATE="PRINT-DU-OWNING-PTR" PARAM-DU=LOCAL-PS-IT
    @@ELSE
      @@INCLUDE TEMPLATE="PRINT-DU" PARAM-DU=LOCAL-PS-IT
    @@ENDIF
  @@FOR-EACH END
@@END-TEMPLATE NAME="PRINT-GENERATE-IMPLEMENTATIONS"


@@BEGIN-TEMPLATE NAME="PRINT-DU"
@@ASSERT IS-SERIALIZABLE-DISCRIMINATED-UNION(PARAM-DU)
void dbgPrint@PARAM-DU.STRUCT-NAME()@( const @PARAM-DU.MAPPING-STRUCT-NAME()@& s, std::ostream& o, size_t offset ) {

  std::string sp( 2 * offset, ' ' );
  std::string sp1( 2 * offset + 2, ' ');

 o << "DISCRIMINATED-UNION @PARAM-DU.STRUCT-NAME()@:\n";

  uint8_t disc = s.@PARAM-DU.MAPPING-DISCRIMINATOR-NAME()@;
  
  o << sp << "@PARAM-DU.MAPPING-DISCRIMINATOR-NAME()@ = " << disc << "\n";

  switch ( disc )
  {
  @@FOR-EACH LOCAL-DU-OPTION IN PARAM-DU.DISCRIMINATED-UNION-OPTIONS()
    case @LOCAL-DU-OPTION.ENCODING-DISCRIMINATED-UNION-OPTION-VALUE()@:
    {
    @@FOR-EACH LOCAL-MEMBER IN LOCAL-DU-OPTION.MEMBERS()
    o << sp << "@LOCAL-MEMBER.MAPPING-MEMBER-NAME()@ = ";
      @@INCLUDE TEMPLATE="PRINT-TYPE" PARAM-NAME=FUNCTION-GET-REF-TO-MEMBER("s", LOCAL-MEMBER) PARAM-TYPE=LOCAL-MEMBER.MEMBER-TYPE()
   @@FOR-EACH END
    }
    break;
  @@FOR-EACH END
    default:
      assert( false );
  }
}
@@END-TEMPLATE NAME="PRINT-DU"


@@BEGIN-TEMPLATE NAME="PRINT-DU-OWNING-PTR"
@@ASSERT IS-SERIALIZABLE-DISCRIMINATED-UNION(PARAM-DU)
@@ASSERT PARAM-DU.GET-MAPPING-ANNOTATION( "OWNING-PTR" ).HAS-VALUE()
void dbgPrint@PARAM-DU.STRUCT-NAME()@( const @PARAM-DU.MAPPING-STRUCT-NAME()@& s, std::ostream& o, size_t offset ) {

  std::string sp( 2 * offset, ' ' );
  std::string sp1( 2 * offset + 2, ' ');

  o << "DISCRIMINATED-UNION @PARAM-DU.STRUCT-NAME()@:\n";

  if( s == nullptr )
    o << sp << "<nullptr>\n";
  @@FOR-EACH LOCAL-DU-OPTION IN PARAM-DU.DISCRIMINATED-UNION-OPTIONS()
    @@FOR-EACH LOCAL-MEMBER IN LOCAL-DU-OPTION.MEMBERS()
      @@ASSERT LOCAL-MEMBER.GET-MAPPING-ANNOTATION( "POLY-POINTER-TYPE" ).HAS-VALUE()
      @@LET LOCAL-POLY-PTR = LOCAL-MEMBER.MEMBER-TYPE().ENCODING-MEMBER-TYPE()
      else if ( typeid( *s ) == typeid( @LOCAL-POLY-PTR@ ) ) {
        auto ptr = dynamic_cast<@LOCAL-POLY-PTR@*>( s.get() );
        dbgPrint@LOCAL-POLY-PTR@( *ptr, o, offset + 1 );
      }
   @@FOR-EACH END
  @@FOR-EACH END
  else
    assert( false );
}
@@END-TEMPLATE NAME="PRINT-DU-OWNING-PTR"

@@BEGIN-TEMPLATE NAME="PRINT-STRUCT"
@@ASSERT IS-SERIALIZABLE-STRUCT(PARAM-STRUCT)
void dbgPrint@PARAM-STRUCT.STRUCT-NAME()@( const @PARAM-STRUCT.STRUCT-NAME()@& s, std::ostream& o, size_t offset ) {

  std::string sp( 2 * offset, ' ' );
  std::string sp1( 2 * offset + 2, ' ');

  o << "PUBLISHABLE-STRUCT @PARAM-STRUCT.STRUCT-NAME()@:\n";

  @@FOR-EACH LOCAL-MEMBER IN PARAM-STRUCT.MEMBERS()
    o << sp << "@LOCAL-MEMBER.MAPPING-MEMBER-NAME()@ = ";
    @@INCLUDE TEMPLATE="PRINT-TYPE" PARAM-NAME=FUNCTION-GET-REF-TO-MEMBER("s", LOCAL-MEMBER) PARAM-TYPE=LOCAL-MEMBER.MEMBER-TYPE()
   @@FOR-EACH END
}
@@END-TEMPLATE NAME="PRINT-STRUCT"


@@BEGIN-TEMPLATE NAME="PRINT-TYPE"
@@ASSERT IS-MEMBER-TYPE(PARAM-TYPE)
@@IF PARAM-TYPE.IS-INTEGER()
  o << @PARAM-NAME@ << "\n";
@@ELIF PARAM-TYPE.IS-ENUM()
  o << @PARAM-NAME@ << "\n";
@@ELIF PARAM-TYPE.IS-FIXED-POINT()
  o << @PARAM-NAME@ << "\n";
@@ELIF PARAM-TYPE.IS-FLOATING-POINT()
  o << @PARAM-NAME@ << "\n";
@@ELIF PARAM-TYPE.IS-CHARACTER-STRING()
  o << "\\"" << @PARAM-NAME@ << "\\"\n";
@@ELIF PARAM-TYPE.IS-STRUCTURE()
    dbgPrint@PARAM-TYPE.ENCODING-MEMBER-TYPE()@(@PARAM-NAME@, o, offset + 1);
@@ELIF PARAM-TYPE.IS-DISCRIMINATED-UNION()
  @@INCLUDE TEMPLATE="PRINT-TYPE" PARAM-NAME="*(@PARAM-NAME@)" PARAM-TYPE=PARAM-TYPE.COLLECTION-TYPE()
@@ELIF PARAM-TYPE.IS-SEQUENCE()
  o << "SEQUENCE\n";
    for(const auto& item:@PARAM-NAME@) {
      o << sp1;
      @@INCLUDE TEMPLATE="PRINT-TYPE" PARAM-NAME="item" PARAM-TYPE=PARAM-TYPE.COLLECTION-TYPE()
    }
@@ELIF PARAM-TYPE.IS-DICTIONARY()
  o << "DICTIONARY\n";
    for(const auto& item:@PARAM-NAME@) {
      o << sp << "{\n"; 
      o << sp1;
      @@INCLUDE TEMPLATE="PRINT-TYPE" PARAM-NAME="item.first" PARAM-TYPE=PARAM-TYPE.COLLECTION-TYPE2()
      o << sp1;
      @@INCLUDE TEMPLATE="PRINT-TYPE" PARAM-NAME="item.second" PARAM-TYPE=PARAM-TYPE.COLLECTION-TYPE()
      o << sp << "}\n";
    }
@@ELSE
  @@ASSERT "0" MSG="Cannot process member for serialization: name=@PARAM-NAME@, type=@PARAM-TYPE.ENCODING-MEMBER-TYPE()@"
@@ENDIF
@@END-TEMPLATE NAME="PRINT-TYPE"



@@--------   COMPARISON   --------


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-GENERATE-DECLARATIONS"
@@ASSERT IS-ROOT(PARAM-ROOT)
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-STRUCTS()
     @@INCLUDE TEMPLATE="ASSERT-EQUAL-DECLARE-FN-ONLY" PARAM-NAME=LOCAL-PS-IT.STRUCT-NAME() PARAM-MAPPING-NAME=LOCAL-PS-IT.MAPPING-STRUCT-NAME()
  @@FOR-EACH END
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-DISCRIMINATED-UNIONS()
     @@INCLUDE TEMPLATE="ASSERT-EQUAL-DECLARE-FN-ONLY" PARAM-NAME=LOCAL-PS-IT.STRUCT-NAME() PARAM-MAPPING-NAME=LOCAL-PS-IT.MAPPING-STRUCT-NAME()
  @@FOR-EACH END

@@END-TEMPLATE NAME="ASSERT-EQUAL-GENERATE-DECLARATIONS"

@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-DECLARE-FN-ONLY"
inline void assertEqual@PARAM-NAME@( const @PARAM-MAPPING-NAME@& left, const @PARAM-MAPPING-NAME@& right );
@@END-TEMPLATE NAME="ASSERT-EQUAL-DECLARE-FN-ONLY"


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-GENERATE-IMPLEMENTATIONS"
@@ASSERT IS-ROOT(PARAM-ROOT)
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-STRUCTS()
     @@INCLUDE TEMPLATE="ASSERT-EQUAL-STRUCT" PARAM-STRUCT=LOCAL-PS-IT
  @@FOR-EACH END
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-DISCRIMINATED-UNIONS()
    @@IF LOCAL-PS-IT.GET-MAPPING-ANNOTATION( "OWNING-PTR" ).HAS-VALUE()
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-DU-OWNING-PTR" PARAM-DU=LOCAL-PS-IT
    @@ELSE
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-DU" PARAM-DU=LOCAL-PS-IT
    @@ENDIF
  @@FOR-EACH END
@@END-TEMPLATE NAME="ASSERT-EQUAL-GENERATE-IMPLEMENTATIONS"

@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-DU"
@@ASSERT IS-SERIALIZABLE-DISCRIMINATED-UNION(PARAM-DU)
inline void assertEqual@PARAM-DU.STRUCT-NAME()@( const @PARAM-DU.MAPPING-STRUCT-NAME()@& left, const @PARAM-DU.MAPPING-STRUCT-NAME()@& right ) {

  uint8_t disc = left.@PARAM-DU.MAPPING-DISCRIMINATOR-NAME()@;
  EXPECT_EQ(disc, right.@PARAM-DU.MAPPING-DISCRIMINATOR-NAME()@);

  switch ( disc )
  {
  @@FOR-EACH LOCAL-DU-OPTION IN PARAM-DU.DISCRIMINATED-UNION-OPTIONS()
    case @LOCAL-DU-OPTION.ENCODING-DISCRIMINATED-UNION-OPTION-VALUE()@:
    {
    @@FOR-EACH LOCAL-MEMBER IN LOCAL-DU-OPTION.MEMBERS()
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-TYPE" PARAM-NAME-LEFT=FUNCTION-GET-REF-TO-MEMBER("left", LOCAL-MEMBER) PARAM-NAME-RIGHT=FUNCTION-GET-REF-TO-MEMBER("right", LOCAL-MEMBER) PARAM-TYPE=LOCAL-MEMBER.MEMBER-TYPE()
    @@FOR-EACH END
    }
    break;
  @@FOR-EACH END
    default:
      assert( false );
  }
}
@@END-TEMPLATE NAME="ASSERT-EQUAL-DU"

@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-DU-OWNING-PTR"
@@ASSERT IS-SERIALIZABLE-DISCRIMINATED-UNION(PARAM-DU)
@@ASSERT PARAM-DU.GET-MAPPING-ANNOTATION( "OWNING-PTR" ).HAS-VALUE()
inline void assertEqual@PARAM-DU.STRUCT-NAME()@( const @PARAM-DU.MAPPING-STRUCT-NAME()@& left, const @PARAM-DU.MAPPING-STRUCT-NAME()@& right ) {

  @@LET LOCAL-DISC=PARAM-DU.MAPPING-DISCRIMINATOR-NAME()
  if(left.get() == nullptr) {
    EXPECT_EQ(right.get(), nullptr);
  }
  @@FOR-EACH LOCAL-MEMBER IN PARAM-DU.MEMBERS()
    @@IF LOCAL-MEMBER.MAPPING-MEMBER-NAME()!=LOCAL-DISC
      @@ASSERT LOCAL-MEMBER.GET-MAPPING-ANNOTATION( "POLY-POINTER-TYPE" ).HAS-VALUE()
      @@LET LOCAL-POLY-PTR = LOCAL-MEMBER.MEMBER-TYPE().ENCODING-MEMBER-TYPE()
  else if(typeid(*left) == typeid(@LOCAL-POLY-PTR@)) {
    auto l = dynamic_cast<@LOCAL-POLY-PTR@*>(left.get());

    EXPECT_EQ(typeid(*right), typeid(@LOCAL-POLY-PTR@));
    auto r = dynamic_cast<@LOCAL-POLY-PTR@*>(right.get());

    assertEqual@LOCAL-POLY-PTR@(*l , *r);
  }
    @@ENDIF
  @@FOR-EACH END
  else {
    EXPECT_TRUE(false);
  }
}
@@END-TEMPLATE NAME="ASSERT-EQUAL-DU-OWNING-PTR"

@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-STRUCT"
@@ASSERT IS-SERIALIZABLE-STRUCT(PARAM-STRUCT)
inline void assertEqual@PARAM-STRUCT.STRUCT-NAME()@( const @PARAM-STRUCT.MAPPING-STRUCT-NAME()@& left, const @PARAM-STRUCT.MAPPING-STRUCT-NAME()@& right ) {
   @@FOR-EACH LOCAL-MEMBER IN PARAM-STRUCT.MEMBERS()
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-TYPE" PARAM-NAME-LEFT=FUNCTION-GET-REF-TO-MEMBER("left", LOCAL-MEMBER) PARAM-NAME-RIGHT=FUNCTION-GET-REF-TO-MEMBER("right", LOCAL-MEMBER) PARAM-TYPE=LOCAL-MEMBER.MEMBER-TYPE()
   @@FOR-EACH END
}

@@END-TEMPLATE NAME="ASSERT-EQUAL-STRUCT"


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-TYPE"
@@ASSERT IS-MEMBER-TYPE(PARAM-TYPE)
@@IF ((PARAM-TYPE.IS-INTEGER()) || (PARAM-TYPE.IS-FIXED-POINT()) || (PARAM-TYPE.IS-FLOATING-POINT()) || (PARAM-TYPE.IS-CHARACTER-STRING()) || (PARAM-TYPE.IS-ENUM()))
    EXPECT_EQ(@PARAM-NAME-LEFT@, @PARAM-NAME-RIGHT@);
@@ELIF PARAM-TYPE.IS-STRUCTURE()
    assertEqual@PARAM-TYPE.ENCODING-MEMBER-TYPE()@(@PARAM-NAME-LEFT@ , @PARAM-NAME-RIGHT@);
@@ELIF PARAM-TYPE.IS-SEQUENCE()
    {
      auto it1 = @PARAM-NAME-LEFT@.begin();
      auto it1_end = @PARAM-NAME-LEFT@.end();
      auto it2 = @PARAM-NAME-RIGHT@.begin();
      auto it2_end = @PARAM-NAME-RIGHT@.end();
      for (; it1 != it1_end && it2 != it2_end; ++it1, ++it2) {
  @@IF PARAM-TYPE.COLLECTION-TYPE().IS-STRUCTURE()
      assertEqual@PARAM-TYPE.COLLECTION-TYPE().ENCODING-MEMBER-TYPE()@(*it1, *it2);
  @@ELSE
      EXPECT_EQ(*it1, *it2);
  @@ENDIF
      }
      EXPECT_EQ(it1, it1_end);
      EXPECT_EQ(it2, it2_end);
    }
@@ELIF PARAM-TYPE.IS-DICTIONARY()
    {
      auto it1 = @PARAM-NAME-LEFT@.begin();
      auto it1_end = @PARAM-NAME-LEFT@.end();
      auto it2 = @PARAM-NAME-RIGHT@.begin();
      auto it2_end = @PARAM-NAME-RIGHT@.end();
      for (; it1 != it1_end && it2 != it2_end; ++it1, ++it2) {
  @@IF PARAM-TYPE.COLLECTION-TYPE2().IS-STRUCTURE()
      assertEqual@PARAM-TYPE.COLLECTION-TYPE2().ENCODING-MEMBER-TYPE()@(it1->first, it2->first);
  @@ELSE
      EXPECT_EQ(it1->first, it2->first);
  @@ENDIF
  @@IF PARAM-TYPE.COLLECTION-TYPE().IS-STRUCTURE()
      assertEqual@PARAM-TYPE.COLLECTION-TYPE().ENCODING-MEMBER-TYPE()@(it1->second, it2->second);
  @@ELSE
      EXPECT_EQ(it1->second, it2->second);
  @@ENDIF
      }
      EXPECT_EQ(it1, it1_end);
      EXPECT_EQ(it2, it2_end);
    }
@@ELSE
  @@ASSERT "0" MSG="Cannot process member for serialization: name=@PARAM-NAME@, type=@PARAM-TYPE.ENCODING-MEMBER-TYPE()@"
@@ENDIF
@@END-TEMPLATE NAME="ASSERT-EQUAL-TYPE"





@@--------   ARE-EQUAL-2-GPB   --------


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-GENERATE-DECLARATIONS"
@@ASSERT IS-ROOT(PARAM-ROOT)
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-STRUCTS()
     @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-DECLARE-FN-ONLY" PARAM-NAME=LOCAL-PS-IT.STRUCT-NAME() PARAM-MAPPING-NAME=LOCAL-PS-IT.MAPPING-STRUCT-NAME()
  @@FOR-EACH END
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-DISCRIMINATED-UNIONS()
     @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-DECLARE-FN-ONLY" PARAM-NAME=LOCAL-PS-IT.STRUCT-NAME() PARAM-MAPPING-NAME=LOCAL-PS-IT.MAPPING-STRUCT-NAME()
  @@FOR-EACH END
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-GENERATE-DECLARATIONS"

@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-DECLARE-FN-ONLY"
inline void assertEqual@PARAM-NAME@( const @PARAM-MAPPING-NAME@& left, const pb::@PARAM-NAME@& right );
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-DECLARE-FN-ONLY"


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-GENERATE-IMPLEMENTATIONS"
@@ASSERT IS-ROOT(PARAM-ROOT)
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-STRUCTS()
     @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-STRUCT" PARAM-STRUCT=LOCAL-PS-IT
  @@FOR-EACH END
  @@FOR-EACH LOCAL-PS-IT IN PARAM-ROOT.PUBLISHABLE-DISCRIMINATED-UNIONS()
    @@IF LOCAL-PS-IT.GET-MAPPING-ANNOTATION( "OWNING-PTR" ).HAS-VALUE()
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-DU-OWNING-PTR" PARAM-DU=LOCAL-PS-IT
    @@ELSE
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-DU" PARAM-DU=LOCAL-PS-IT
    @@ENDIF
  @@FOR-EACH END
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-GENERATE-IMPLEMENTATIONS"


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-DU"
@@ASSERT IS-SERIALIZABLE-DISCRIMINATED-UNION(PARAM-DU)
inline void assertEqual@PARAM-DU.STRUCT-NAME()@( const @PARAM-DU.MAPPING-STRUCT-NAME()@& left, const pb::@PARAM-DU.STRUCT-NAME()@& right ) {

  uint8_t disc = left.@PARAM-DU.MAPPING-DISCRIMINATOR-NAME()@;
  EXPECT_EQ( disc, right.@PARAM-DU.MAPPING-DISCRIMINATOR-NAME().CAMEL-CASE-TO-LOWER-UNDERSCORE()@() );

  switch ( disc )
  {
  @@FOR-EACH LOCAL-DU-OPTION IN PARAM-DU.DISCRIMINATED-UNION-OPTIONS()
    case @LOCAL-DU-OPTION.ENCODING-DISCRIMINATED-UNION-OPTION-VALUE()@:
    {
    @@FOR-EACH LOCAL-MEMBER IN LOCAL-DU-OPTION.MEMBERS()
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-TYPE" PARAM-NAME-LEFT=FUNCTION-GET-REF-TO-MEMBER("left", LOCAL-MEMBER) PARAM-NAME-RIGHT=FUNCTION-GET-REF-TO-MEMBER-PROTO("right", LOCAL-MEMBER) PARAM-TYPE=LOCAL-MEMBER.MEMBER-TYPE()
    @@FOR-EACH END
    }
    break;
  @@FOR-EACH END
    default:
      assert( false );
  }

}
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-DU"

@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-DU-OWNING-PTR"
@@ASSERT IS-SERIALIZABLE-DISCRIMINATED-UNION(PARAM-DU)
@@ASSERT PARAM-DU.GET-MAPPING-ANNOTATION( "OWNING-PTR" ).HAS-VALUE()
inline void assertEqual@PARAM-DU.STRUCT-NAME()@( const @PARAM-DU.MAPPING-STRUCT-NAME()@& left, const pb::@PARAM-DU.STRUCT-NAME()@& right ) {

  if(left.get() == nullptr) {
    ;//do nothing
  }
  @@FOR-EACH LOCAL-DU-OPTION IN PARAM-DU.DISCRIMINATED-UNION-OPTIONS()
    @@FOR-EACH LOCAL-MEMBER IN LOCAL-DU-OPTION.MEMBERS()
      @@ASSERT LOCAL-MEMBER.GET-MAPPING-ANNOTATION( "POLY-POINTER-TYPE" ).HAS-VALUE()
      @@LET LOCAL-POLY-PTR = LOCAL-MEMBER.MEMBER-TYPE().ENCODING-MEMBER-TYPE()
      @@LET LOCAL-RIGHT-NAME="@LOCAL-MEMBER.MAPPING-MEMBER-NAME().CAMEL-CASE-TO-LOWER-UNDERSCORE()@()"
  else if(typeid(*left) == typeid(@LOCAL-POLY-PTR@)) {
    auto l = dynamic_cast<@LOCAL-POLY-PTR@*>(left.get());

    assertEqual@LOCAL-POLY-PTR@(*l , right.@LOCAL-RIGHT-NAME@);
  }
    @@FOR-EACH END
  @@FOR-EACH END
   else {
     EXPECT_TRUE(false);
   }
}
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-DU-OWNING-PTR"


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-STRUCT"
@@ASSERT IS-SERIALIZABLE-STRUCT(PARAM-STRUCT)
inline void assertEqual@PARAM-STRUCT.STRUCT-NAME()@( const @PARAM-STRUCT.MAPPING-STRUCT-NAME()@& left, const pb::@PARAM-STRUCT.MAPPING-STRUCT-NAME()@& right ) {
  @@FOR-EACH LOCAL-MEMBER IN PARAM-STRUCT.MEMBERS()
    @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-TYPE" PARAM-NAME-LEFT=FUNCTION-GET-REF-TO-MEMBER("left", LOCAL-MEMBER) PARAM-NAME-RIGHT=FUNCTION-GET-REF-TO-MEMBER-PROTO("right", LOCAL-MEMBER) PARAM-TYPE=LOCAL-MEMBER.MEMBER-TYPE()
  @@FOR-EACH END
}
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-STRUCT"

@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-TYPE"
@@ASSERT IS-MEMBER-TYPE(PARAM-TYPE)
@@IF ((PARAM-TYPE.IS-INTEGER()) || (PARAM-TYPE.IS-FIXED-POINT()) || (PARAM-TYPE.IS-FLOATING-POINT()) || (PARAM-TYPE.IS-CHARACTER-STRING()))
    EXPECT_EQ(@PARAM-NAME-LEFT@, @PARAM-NAME-RIGHT@);
@@ELIF PARAM-TYPE.IS-ENUM()
  @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-ENUM" PARAM-TYPE=PARAM-TYPE PARAM-NAME-LEFT=PARAM-NAME-LEFT PARAM-NAME-RIGHT=PARAM-NAME-RIGHT
@@ELIF PARAM-TYPE.IS-STRUCTURE()
    assertEqual@PARAM-TYPE.ENCODING-MEMBER-TYPE()@(@PARAM-NAME-LEFT@ , @PARAM-NAME-RIGHT@);
@@ELIF PARAM-TYPE.IS-SEQUENCE()
    {
      auto it1 = @PARAM-NAME-LEFT@.begin();
      auto it1_end = @PARAM-NAME-LEFT@.end();
      auto it2 = @PARAM-NAME-RIGHT@.begin();
      auto it2_end = @PARAM-NAME-RIGHT@.end();
      for (; it1 != it1_end && it2 != it2_end; ++it1, ++it2) {
  @@IF PARAM-TYPE.COLLECTION-TYPE().IS-STRUCTURE()
      assertEqual@PARAM-TYPE.COLLECTION-TYPE().ENCODING-MEMBER-TYPE()@(*it1, *it2);
  @@ELIF PARAM-TYPE.COLLECTION-TYPE().IS-ENUM()
    @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-ENUM" PARAM-TYPE=PARAM-TYPE.COLLECTION-TYPE() PARAM-NAME-LEFT="*it1" PARAM-NAME-RIGHT="*it2"
  @@ELSE
      EXPECT_EQ(*it1, *it2);
  @@ENDIF
      }
      EXPECT_EQ(it1, it1_end);
      EXPECT_EQ(it2, it2_end);
    }
@@ELIF PARAM-TYPE.IS-DICTIONARY()
  @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-MAP" PARAM-TYPE=PARAM-TYPE PARAM-NAME-LEFT=PARAM-NAME-LEFT PARAM-NAME-RIGHT=PARAM-NAME-RIGHT
@@ELSE
  @@ASSERT "0" MSG="Cannot process member for serialization: name=@PARAM-NAME@, type=@PARAM-TYPE.ENCODING-MEMBER-TYPE()@"
@@ENDIF
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-TYPE"


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-ENUM"
@@ASSERT PARAM-TYPE.IS-ENUM()
        switch(@PARAM-NAME-LEFT@)
        {
  @@FOR-EACH LOCAL-ENUM-VAL IN PARAM-TYPE.ENUM-VALUES()
          case /* @LOCAL-ENUM-VAL.ENUM-VALUE-NAME()@ */ @LOCAL-ENUM-VAL.MAPPING-ENUM-VALUE-VALUE()@: EXPECT_TRUE(@PARAM-NAME-RIGHT@ == @LOCAL-ENUM-VAL.ENCODING-ENUM-VALUE-VALUE()@); break;
  @@FOR-EACH END
          default: EXPECT_TRUE(false);
        }
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-ENUM"


@@BEGIN-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-MAP"
@@ASSERT PARAM-TYPE.IS-DICTIONARY()

    {
      auto it1 = @PARAM-NAME-LEFT@.begin();
      auto it1_end = @PARAM-NAME-LEFT@.end();
      auto it2 = @PARAM-NAME-RIGHT@.begin();
      auto it2_end = @PARAM-NAME-RIGHT@.end();
      for (; it1 != it1_end && it2 != it2_end; ++it1, ++it2) {
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-TYPE" PARAM-NAME-LEFT="it1->first" PARAM-NAME-RIGHT="it2->key()" PARAM-TYPE=PARAM-TYPE.COLLECTION-TYPE2()
      @@INCLUDE TEMPLATE="ASSERT-EQUAL-2-GPB-TYPE" PARAM-NAME-LEFT="it1->second" PARAM-NAME-RIGHT="it2->value()" PARAM-TYPE=PARAM-TYPE.COLLECTION-TYPE()
      }
      EXPECT_TRUE(it1 == it1_end);
      EXPECT_TRUE(it2 == it2_end);
    }
@@END-TEMPLATE NAME="ASSERT-EQUAL-2-GPB-MAP"
