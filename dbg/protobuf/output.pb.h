// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: output.proto

#ifndef PROTOBUF_output_2eproto__INCLUDED
#define PROTOBUF_output_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_output_2eproto();
void protobuf_AssignDesc_output_2eproto();
void protobuf_ShutdownFile_output_2eproto();

class Limit;
class Location;
class CharacterRange;
class CharacterSet;
class Variant;
class DataType;
class EncodingSpecifics;
class EncodedOrMember;
class DataMember;
class EncodedMembers;
class Structure;
class Typedef;
class Root;
class __unique_ptr_DataType;
class __unique_ptr_EncodedOrMember;
class __unique_ptr_Structure;
class map_string_Variant;
class map_string_uint32;

enum Variant_KIND {
  Variant_KIND_NONE = 0,
  Variant_KIND_NUMBER = 1,
  Variant_KIND_STRING = 2
};
bool Variant_KIND_IsValid(int value);
const Variant_KIND Variant_KIND_KIND_MIN = Variant_KIND_NONE;
const Variant_KIND Variant_KIND_KIND_MAX = Variant_KIND_STRING;
const int Variant_KIND_KIND_ARRAYSIZE = Variant_KIND_KIND_MAX + 1;

const ::google::protobuf::EnumDescriptor* Variant_KIND_descriptor();
inline const ::std::string& Variant_KIND_Name(Variant_KIND value) {
  return ::google::protobuf::internal::NameOfEnum(
    Variant_KIND_descriptor(), value);
}
inline bool Variant_KIND_Parse(
    const ::std::string& name, Variant_KIND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Variant_KIND>(
    Variant_KIND_descriptor(), name, value);
}
enum DataType_KIND {
  DataType_KIND_BIT_STRING = 0,
  DataType_KIND_CHARACTER = 1,
  DataType_KIND_CHARACTER_STRING = 2,
  DataType_KIND_DICTIONARY = 3,
  DataType_KIND_DISCRIMINATED_UNION = 4,
  DataType_KIND_ENCODING_SPECIFIC = 5,
  DataType_KIND_ENUM = 6,
  DataType_KIND_FIXED_POINT = 7,
  DataType_KIND_FLOATING_POINT = 8,
  DataType_KIND_INTEGER = 9,
  DataType_KIND_MAPPING_SPECIFIC = 10,
  DataType_KIND_NAMED_TYPE = 11,
  DataType_KIND_SEQUENCE = 12
};
bool DataType_KIND_IsValid(int value);
const DataType_KIND DataType_KIND_KIND_MIN = DataType_KIND_BIT_STRING;
const DataType_KIND DataType_KIND_KIND_MAX = DataType_KIND_SEQUENCE;
const int DataType_KIND_KIND_ARRAYSIZE = DataType_KIND_KIND_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_KIND_descriptor();
inline const ::std::string& DataType_KIND_Name(DataType_KIND value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_KIND_descriptor(), value);
}
inline bool DataType_KIND_Parse(
    const ::std::string& name, DataType_KIND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType_KIND>(
    DataType_KIND_descriptor(), name, value);
}
enum Structure_DECLTYPE {
  Structure_DECLTYPE_ENCODING = 0,
  Structure_DECLTYPE_IDL = 1,
  Structure_DECLTYPE_MAPPING = 2
};
bool Structure_DECLTYPE_IsValid(int value);
const Structure_DECLTYPE Structure_DECLTYPE_DECLTYPE_MIN = Structure_DECLTYPE_ENCODING;
const Structure_DECLTYPE Structure_DECLTYPE_DECLTYPE_MAX = Structure_DECLTYPE_MAPPING;
const int Structure_DECLTYPE_DECLTYPE_ARRAYSIZE = Structure_DECLTYPE_DECLTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Structure_DECLTYPE_descriptor();
inline const ::std::string& Structure_DECLTYPE_Name(Structure_DECLTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Structure_DECLTYPE_descriptor(), value);
}
inline bool Structure_DECLTYPE_Parse(
    const ::std::string& name, Structure_DECLTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Structure_DECLTYPE>(
    Structure_DECLTYPE_descriptor(), name, value);
}
enum Structure_TYPE {
  Structure_TYPE_DISCRIMINATED_UNION = 0,
  Structure_TYPE_RPC = 1,
  Structure_TYPE_STRUCT = 2
};
bool Structure_TYPE_IsValid(int value);
const Structure_TYPE Structure_TYPE_TYPE_MIN = Structure_TYPE_DISCRIMINATED_UNION;
const Structure_TYPE Structure_TYPE_TYPE_MAX = Structure_TYPE_STRUCT;
const int Structure_TYPE_TYPE_ARRAYSIZE = Structure_TYPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Structure_TYPE_descriptor();
inline const ::std::string& Structure_TYPE_Name(Structure_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Structure_TYPE_descriptor(), value);
}
inline bool Structure_TYPE_Parse(
    const ::std::string& name, Structure_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Structure_TYPE>(
    Structure_TYPE_descriptor(), name, value);
}
enum __unique_ptr_DataType_Discriminator {
  __unique_ptr_DataType_Discriminator_OPT_DataType = 0,
  __unique_ptr_DataType_Discriminator_OPT_nullptr = 1
};
bool __unique_ptr_DataType_Discriminator_IsValid(int value);
const __unique_ptr_DataType_Discriminator __unique_ptr_DataType_Discriminator_Discriminator_MIN = __unique_ptr_DataType_Discriminator_OPT_DataType;
const __unique_ptr_DataType_Discriminator __unique_ptr_DataType_Discriminator_Discriminator_MAX = __unique_ptr_DataType_Discriminator_OPT_nullptr;
const int __unique_ptr_DataType_Discriminator_Discriminator_ARRAYSIZE = __unique_ptr_DataType_Discriminator_Discriminator_MAX + 1;

const ::google::protobuf::EnumDescriptor* __unique_ptr_DataType_Discriminator_descriptor();
inline const ::std::string& __unique_ptr_DataType_Discriminator_Name(__unique_ptr_DataType_Discriminator value) {
  return ::google::protobuf::internal::NameOfEnum(
    __unique_ptr_DataType_Discriminator_descriptor(), value);
}
inline bool __unique_ptr_DataType_Discriminator_Parse(
    const ::std::string& name, __unique_ptr_DataType_Discriminator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<__unique_ptr_DataType_Discriminator>(
    __unique_ptr_DataType_Discriminator_descriptor(), name, value);
}
enum __unique_ptr_EncodedOrMember_Discriminator {
  __unique_ptr_EncodedOrMember_Discriminator_OPT_DataMember = 0,
  __unique_ptr_EncodedOrMember_Discriminator_OPT_EncodedMembers = 1,
  __unique_ptr_EncodedOrMember_Discriminator_OPT_EncodedOrMember = 2,
  __unique_ptr_EncodedOrMember_Discriminator_OPT_nullptr = 3
};
bool __unique_ptr_EncodedOrMember_Discriminator_IsValid(int value);
const __unique_ptr_EncodedOrMember_Discriminator __unique_ptr_EncodedOrMember_Discriminator_Discriminator_MIN = __unique_ptr_EncodedOrMember_Discriminator_OPT_DataMember;
const __unique_ptr_EncodedOrMember_Discriminator __unique_ptr_EncodedOrMember_Discriminator_Discriminator_MAX = __unique_ptr_EncodedOrMember_Discriminator_OPT_nullptr;
const int __unique_ptr_EncodedOrMember_Discriminator_Discriminator_ARRAYSIZE = __unique_ptr_EncodedOrMember_Discriminator_Discriminator_MAX + 1;

const ::google::protobuf::EnumDescriptor* __unique_ptr_EncodedOrMember_Discriminator_descriptor();
inline const ::std::string& __unique_ptr_EncodedOrMember_Discriminator_Name(__unique_ptr_EncodedOrMember_Discriminator value) {
  return ::google::protobuf::internal::NameOfEnum(
    __unique_ptr_EncodedOrMember_Discriminator_descriptor(), value);
}
inline bool __unique_ptr_EncodedOrMember_Discriminator_Parse(
    const ::std::string& name, __unique_ptr_EncodedOrMember_Discriminator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<__unique_ptr_EncodedOrMember_Discriminator>(
    __unique_ptr_EncodedOrMember_Discriminator_descriptor(), name, value);
}
enum __unique_ptr_Structure_Discriminator {
  __unique_ptr_Structure_Discriminator_OPT_Structure = 0,
  __unique_ptr_Structure_Discriminator_OPT_nullptr = 1
};
bool __unique_ptr_Structure_Discriminator_IsValid(int value);
const __unique_ptr_Structure_Discriminator __unique_ptr_Structure_Discriminator_Discriminator_MIN = __unique_ptr_Structure_Discriminator_OPT_Structure;
const __unique_ptr_Structure_Discriminator __unique_ptr_Structure_Discriminator_Discriminator_MAX = __unique_ptr_Structure_Discriminator_OPT_nullptr;
const int __unique_ptr_Structure_Discriminator_Discriminator_ARRAYSIZE = __unique_ptr_Structure_Discriminator_Discriminator_MAX + 1;

const ::google::protobuf::EnumDescriptor* __unique_ptr_Structure_Discriminator_descriptor();
inline const ::std::string& __unique_ptr_Structure_Discriminator_Name(__unique_ptr_Structure_Discriminator value) {
  return ::google::protobuf::internal::NameOfEnum(
    __unique_ptr_Structure_Discriminator_descriptor(), value);
}
inline bool __unique_ptr_Structure_Discriminator_Parse(
    const ::std::string& name, __unique_ptr_Structure_Discriminator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<__unique_ptr_Structure_Discriminator>(
    __unique_ptr_Structure_Discriminator_descriptor(), name, value);
}
// ===================================================================

class Limit : public ::google::protobuf::Message {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  void Swap(Limit* other);

  // implements Message ----------------------------------------------

  Limit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool inclusive = 1;
  inline bool has_inclusive() const;
  inline void clear_inclusive();
  static const int kInclusiveFieldNumber = 1;
  inline bool inclusive() const;
  inline void set_inclusive(bool value);

  // optional double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:pb.Limit)
 private:
  inline void set_has_inclusive();
  inline void clear_has_inclusive();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double value_;
  bool inclusive_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static Limit* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional sint32 line_number = 2;
  inline bool has_line_number() const;
  inline void clear_line_number();
  static const int kLineNumberFieldNumber = 2;
  inline ::google::protobuf::int32 line_number() const;
  inline void set_line_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Location)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_line_number();
  inline void clear_has_line_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* file_name_;
  ::google::protobuf::int32 line_number_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class CharacterRange : public ::google::protobuf::Message {
 public:
  CharacterRange();
  virtual ~CharacterRange();

  CharacterRange(const CharacterRange& from);

  inline CharacterRange& operator=(const CharacterRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharacterRange& default_instance();

  void Swap(CharacterRange* other);

  // implements Message ----------------------------------------------

  CharacterRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharacterRange& from);
  void MergeFrom(const CharacterRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline ::google::protobuf::uint32 from() const;
  inline void set_from(::google::protobuf::uint32 value);

  // optional uint32 to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline ::google::protobuf::uint32 to() const;
  inline void set_to(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CharacterRange)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_;
  ::google::protobuf::uint32 to_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static CharacterRange* default_instance_;
};
// -------------------------------------------------------------------

class CharacterSet : public ::google::protobuf::Message {
 public:
  CharacterSet();
  virtual ~CharacterSet();

  CharacterSet(const CharacterSet& from);

  inline CharacterSet& operator=(const CharacterSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharacterSet& default_instance();

  void Swap(CharacterSet* other);

  // implements Message ----------------------------------------------

  CharacterSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharacterSet& from);
  void MergeFrom(const CharacterSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.CharacterRange ranges = 1;
  inline int ranges_size() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 1;
  inline const ::pb::CharacterRange& ranges(int index) const;
  inline ::pb::CharacterRange* mutable_ranges(int index);
  inline ::pb::CharacterRange* add_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CharacterRange >&
      ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CharacterRange >*
      mutable_ranges();

  // @@protoc_insertion_point(class_scope:pb.CharacterSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::CharacterRange > ranges_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static CharacterSet* default_instance_;
};
// -------------------------------------------------------------------

class Variant : public ::google::protobuf::Message {
 public:
  Variant();
  virtual ~Variant();

  Variant(const Variant& from);

  inline Variant& operator=(const Variant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Variant& default_instance();

  void Swap(Variant* other);

  // implements Message ----------------------------------------------

  Variant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Variant& from);
  void MergeFrom(const Variant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Variant_KIND KIND;
  static const KIND NONE = Variant_KIND_NONE;
  static const KIND NUMBER = Variant_KIND_NUMBER;
  static const KIND STRING = Variant_KIND_STRING;
  static inline bool KIND_IsValid(int value) {
    return Variant_KIND_IsValid(value);
  }
  static const KIND KIND_MIN =
    Variant_KIND_KIND_MIN;
  static const KIND KIND_MAX =
    Variant_KIND_KIND_MAX;
  static const int KIND_ARRAYSIZE =
    Variant_KIND_KIND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KIND_descriptor() {
    return Variant_KIND_descriptor();
  }
  static inline const ::std::string& KIND_Name(KIND value) {
    return Variant_KIND_Name(value);
  }
  static inline bool KIND_Parse(const ::std::string& name,
      KIND* value) {
    return Variant_KIND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pb.Variant.KIND kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::pb::Variant_KIND kind() const;
  inline void set_kind(::pb::Variant_KIND value);

  // optional double number_value = 2;
  inline bool has_number_value() const;
  inline void clear_number_value();
  static const int kNumberValueFieldNumber = 2;
  inline double number_value() const;
  inline void set_number_value(double value);

  // optional string string_value = 3;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 3;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // @@protoc_insertion_point(class_scope:pb.Variant)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_number_value();
  inline void clear_has_number_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double number_value_;
  ::std::string* string_value_;
  int kind_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static Variant* default_instance_;
};
// -------------------------------------------------------------------

class DataType : public ::google::protobuf::Message {
 public:
  DataType();
  virtual ~DataType();

  DataType(const DataType& from);

  inline DataType& operator=(const DataType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataType& default_instance();

  void Swap(DataType* other);

  // implements Message ----------------------------------------------

  DataType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataType& from);
  void MergeFrom(const DataType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DataType_KIND KIND;
  static const KIND BIT_STRING = DataType_KIND_BIT_STRING;
  static const KIND CHARACTER = DataType_KIND_CHARACTER;
  static const KIND CHARACTER_STRING = DataType_KIND_CHARACTER_STRING;
  static const KIND DICTIONARY = DataType_KIND_DICTIONARY;
  static const KIND DISCRIMINATED_UNION = DataType_KIND_DISCRIMINATED_UNION;
  static const KIND ENCODING_SPECIFIC = DataType_KIND_ENCODING_SPECIFIC;
  static const KIND ENUM = DataType_KIND_ENUM;
  static const KIND FIXED_POINT = DataType_KIND_FIXED_POINT;
  static const KIND FLOATING_POINT = DataType_KIND_FLOATING_POINT;
  static const KIND INTEGER = DataType_KIND_INTEGER;
  static const KIND MAPPING_SPECIFIC = DataType_KIND_MAPPING_SPECIFIC;
  static const KIND NAMED_TYPE = DataType_KIND_NAMED_TYPE;
  static const KIND SEQUENCE = DataType_KIND_SEQUENCE;
  static inline bool KIND_IsValid(int value) {
    return DataType_KIND_IsValid(value);
  }
  static const KIND KIND_MIN =
    DataType_KIND_KIND_MIN;
  static const KIND KIND_MAX =
    DataType_KIND_KIND_MAX;
  static const int KIND_ARRAYSIZE =
    DataType_KIND_KIND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KIND_descriptor() {
    return DataType_KIND_descriptor();
  }
  static inline const ::std::string& KIND_Name(KIND value) {
    return DataType_KIND_Name(value);
  }
  static inline bool KIND_Parse(const ::std::string& name,
      KIND* value) {
    return DataType_KIND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pb.DataType.KIND kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::pb::DataType_KIND kind() const;
  inline void set_kind(::pb::DataType_KIND value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string mapping_name = 3;
  inline bool has_mapping_name() const;
  inline void clear_mapping_name();
  static const int kMappingNameFieldNumber = 3;
  inline const ::std::string& mapping_name() const;
  inline void set_mapping_name(const ::std::string& value);
  inline void set_mapping_name(const char* value);
  inline void set_mapping_name(const char* value, size_t size);
  inline ::std::string* mutable_mapping_name();
  inline ::std::string* release_mapping_name();
  inline void set_allocated_mapping_name(::std::string* mapping_name);

  // optional string encoding_name = 4;
  inline bool has_encoding_name() const;
  inline void clear_encoding_name();
  static const int kEncodingNameFieldNumber = 4;
  inline const ::std::string& encoding_name() const;
  inline void set_encoding_name(const ::std::string& value);
  inline void set_encoding_name(const char* value);
  inline void set_encoding_name(const char* value, size_t size);
  inline ::std::string* mutable_encoding_name();
  inline ::std::string* release_encoding_name();
  inline void set_allocated_encoding_name(::std::string* encoding_name);

  // optional .pb.__unique_ptr_DataType key_type = 5;
  inline bool has_key_type() const;
  inline void clear_key_type();
  static const int kKeyTypeFieldNumber = 5;
  inline const ::pb::__unique_ptr_DataType& key_type() const;
  inline ::pb::__unique_ptr_DataType* mutable_key_type();
  inline ::pb::__unique_ptr_DataType* release_key_type();
  inline void set_allocated_key_type(::pb::__unique_ptr_DataType* key_type);

  // optional .pb.__unique_ptr_DataType param_type = 6;
  inline bool has_param_type() const;
  inline void clear_param_type();
  static const int kParamTypeFieldNumber = 6;
  inline const ::pb::__unique_ptr_DataType& param_type() const;
  inline ::pb::__unique_ptr_DataType* mutable_param_type();
  inline ::pb::__unique_ptr_DataType* release_param_type();
  inline void set_allocated_param_type(::pb::__unique_ptr_DataType* param_type);

  // optional .pb.Limit low_limit = 7;
  inline bool has_low_limit() const;
  inline void clear_low_limit();
  static const int kLowLimitFieldNumber = 7;
  inline const ::pb::Limit& low_limit() const;
  inline ::pb::Limit* mutable_low_limit();
  inline ::pb::Limit* release_low_limit();
  inline void set_allocated_low_limit(::pb::Limit* low_limit);

  // optional .pb.Limit high_limit = 8;
  inline bool has_high_limit() const;
  inline void clear_high_limit();
  static const int kHighLimitFieldNumber = 8;
  inline const ::pb::Limit& high_limit() const;
  inline ::pb::Limit* mutable_high_limit();
  inline ::pb::Limit* release_high_limit();
  inline void set_allocated_high_limit(::pb::Limit* high_limit);

  // optional double fixed_precision = 9;
  inline bool has_fixed_precision() const;
  inline void clear_fixed_precision();
  static const int kFixedPrecisionFieldNumber = 9;
  inline double fixed_precision() const;
  inline void set_fixed_precision(double value);

  // optional uint32 floating_significand_bits = 10;
  inline bool has_floating_significand_bits() const;
  inline void clear_floating_significand_bits();
  static const int kFloatingSignificandBitsFieldNumber = 10;
  inline ::google::protobuf::uint32 floating_significand_bits() const;
  inline void set_floating_significand_bits(::google::protobuf::uint32 value);

  // optional uint32 floating_exponent_bits = 11;
  inline bool has_floating_exponent_bits() const;
  inline void clear_floating_exponent_bits();
  static const int kFloatingExponentBitsFieldNumber = 11;
  inline ::google::protobuf::uint32 floating_exponent_bits() const;
  inline void set_floating_exponent_bits(::google::protobuf::uint32 value);

  // optional .pb.CharacterSet character_set = 12;
  inline bool has_character_set() const;
  inline void clear_character_set();
  static const int kCharacterSetFieldNumber = 12;
  inline const ::pb::CharacterSet& character_set() const;
  inline ::pb::CharacterSet* mutable_character_set();
  inline ::pb::CharacterSet* release_character_set();
  inline void set_allocated_character_set(::pb::CharacterSet* character_set);

  // optional uint32 string_min_size = 13;
  inline bool has_string_min_size() const;
  inline void clear_string_min_size();
  static const int kStringMinSizeFieldNumber = 13;
  inline ::google::protobuf::uint32 string_min_size() const;
  inline void set_string_min_size(::google::protobuf::uint32 value);

  // optional uint32 string_max_size = 14;
  inline bool has_string_max_size() const;
  inline void clear_string_max_size();
  static const int kStringMaxSizeFieldNumber = 14;
  inline ::google::protobuf::uint32 string_max_size() const;
  inline void set_string_max_size(::google::protobuf::uint32 value);

  // repeated .pb.map_string_Variant encoding_attrs = 15;
  inline int encoding_attrs_size() const;
  inline void clear_encoding_attrs();
  static const int kEncodingAttrsFieldNumber = 15;
  inline const ::pb::map_string_Variant& encoding_attrs(int index) const;
  inline ::pb::map_string_Variant* mutable_encoding_attrs(int index);
  inline ::pb::map_string_Variant* add_encoding_attrs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >&
      encoding_attrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >*
      mutable_encoding_attrs();

  // repeated .pb.map_string_Variant mapping_attrs = 16;
  inline int mapping_attrs_size() const;
  inline void clear_mapping_attrs();
  static const int kMappingAttrsFieldNumber = 16;
  inline const ::pb::map_string_Variant& mapping_attrs(int index) const;
  inline ::pb::map_string_Variant* mutable_mapping_attrs(int index);
  inline ::pb::map_string_Variant* add_mapping_attrs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >&
      mapping_attrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >*
      mutable_mapping_attrs();

  // repeated .pb.map_string_uint32 enum_values = 17;
  inline int enum_values_size() const;
  inline void clear_enum_values();
  static const int kEnumValuesFieldNumber = 17;
  inline const ::pb::map_string_uint32& enum_values(int index) const;
  inline ::pb::map_string_uint32* mutable_enum_values(int index);
  inline ::pb::map_string_uint32* add_enum_values();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_uint32 >&
      enum_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_uint32 >*
      mutable_enum_values();

  // @@protoc_insertion_point(class_scope:pb.DataType)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mapping_name();
  inline void clear_has_mapping_name();
  inline void set_has_encoding_name();
  inline void clear_has_encoding_name();
  inline void set_has_key_type();
  inline void clear_has_key_type();
  inline void set_has_param_type();
  inline void clear_has_param_type();
  inline void set_has_low_limit();
  inline void clear_has_low_limit();
  inline void set_has_high_limit();
  inline void clear_has_high_limit();
  inline void set_has_fixed_precision();
  inline void clear_has_fixed_precision();
  inline void set_has_floating_significand_bits();
  inline void clear_has_floating_significand_bits();
  inline void set_has_floating_exponent_bits();
  inline void clear_has_floating_exponent_bits();
  inline void set_has_character_set();
  inline void clear_has_character_set();
  inline void set_has_string_min_size();
  inline void clear_has_string_min_size();
  inline void set_has_string_max_size();
  inline void clear_has_string_max_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* mapping_name_;
  ::std::string* encoding_name_;
  ::pb::__unique_ptr_DataType* key_type_;
  int kind_;
  ::google::protobuf::uint32 floating_significand_bits_;
  ::pb::__unique_ptr_DataType* param_type_;
  ::pb::Limit* low_limit_;
  ::pb::Limit* high_limit_;
  double fixed_precision_;
  ::pb::CharacterSet* character_set_;
  ::google::protobuf::uint32 floating_exponent_bits_;
  ::google::protobuf::uint32 string_min_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant > encoding_attrs_;
  ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant > mapping_attrs_;
  ::google::protobuf::RepeatedPtrField< ::pb::map_string_uint32 > enum_values_;
  ::google::protobuf::uint32 string_max_size_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static DataType* default_instance_;
};
// -------------------------------------------------------------------

class EncodingSpecifics : public ::google::protobuf::Message {
 public:
  EncodingSpecifics();
  virtual ~EncodingSpecifics();

  EncodingSpecifics(const EncodingSpecifics& from);

  inline EncodingSpecifics& operator=(const EncodingSpecifics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncodingSpecifics& default_instance();

  void Swap(EncodingSpecifics* other);

  // implements Message ----------------------------------------------

  EncodingSpecifics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncodingSpecifics& from);
  void MergeFrom(const EncodingSpecifics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.map_string_Variant attrs = 2;
  inline int attrs_size() const;
  inline void clear_attrs();
  static const int kAttrsFieldNumber = 2;
  inline const ::pb::map_string_Variant& attrs(int index) const;
  inline ::pb::map_string_Variant* mutable_attrs(int index);
  inline ::pb::map_string_Variant* add_attrs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >&
      attrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >*
      mutable_attrs();

  // @@protoc_insertion_point(class_scope:pb.EncodingSpecifics)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant > attrs_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static EncodingSpecifics* default_instance_;
};
// -------------------------------------------------------------------

class EncodedOrMember : public ::google::protobuf::Message {
 public:
  EncodedOrMember();
  virtual ~EncodedOrMember();

  EncodedOrMember(const EncodedOrMember& from);

  inline EncodedOrMember& operator=(const EncodedOrMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncodedOrMember& default_instance();

  void Swap(EncodedOrMember* other);

  // implements Message ----------------------------------------------

  EncodedOrMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncodedOrMember& from);
  void MergeFrom(const EncodedOrMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.Location location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::pb::Location& location() const;
  inline ::pb::Location* mutable_location();
  inline ::pb::Location* release_location();
  inline void set_allocated_location(::pb::Location* location);

  // @@protoc_insertion_point(class_scope:pb.EncodedOrMember)
 private:
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::Location* location_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static EncodedOrMember* default_instance_;
};
// -------------------------------------------------------------------

class DataMember : public ::google::protobuf::Message {
 public:
  DataMember();
  virtual ~DataMember();

  DataMember(const DataMember& from);

  inline DataMember& operator=(const DataMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMember& default_instance();

  void Swap(DataMember* other);

  // implements Message ----------------------------------------------

  DataMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMember& from);
  void MergeFrom(const DataMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.DataType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::pb::DataType& type() const;
  inline ::pb::DataType* mutable_type();
  inline ::pb::DataType* release_type();
  inline void set_allocated_type(::pb::DataType* type);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool extend_to = 3;
  inline bool has_extend_to() const;
  inline void clear_extend_to();
  static const int kExtendToFieldNumber = 3;
  inline bool extend_to() const;
  inline void set_extend_to(bool value);

  // optional .pb.Variant default_value = 4;
  inline bool has_default_value() const;
  inline void clear_default_value();
  static const int kDefaultValueFieldNumber = 4;
  inline const ::pb::Variant& default_value() const;
  inline ::pb::Variant* mutable_default_value();
  inline ::pb::Variant* release_default_value();
  inline void set_allocated_default_value(::pb::Variant* default_value);

  // repeated string when_discriminant = 5;
  inline int when_discriminant_size() const;
  inline void clear_when_discriminant();
  static const int kWhenDiscriminantFieldNumber = 5;
  inline const ::std::string& when_discriminant(int index) const;
  inline ::std::string* mutable_when_discriminant(int index);
  inline void set_when_discriminant(int index, const ::std::string& value);
  inline void set_when_discriminant(int index, const char* value);
  inline void set_when_discriminant(int index, const char* value, size_t size);
  inline ::std::string* add_when_discriminant();
  inline void add_when_discriminant(const ::std::string& value);
  inline void add_when_discriminant(const char* value);
  inline void add_when_discriminant(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& when_discriminant() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_when_discriminant();

  // optional .pb.EncodedOrMember __parent = 6;
  inline bool has___parent() const;
  inline void clear___parent();
  static const int kParentFieldNumber = 6;
  inline const ::pb::EncodedOrMember& __parent() const;
  inline ::pb::EncodedOrMember* mutable___parent();
  inline ::pb::EncodedOrMember* release___parent();
  inline void set_allocated___parent(::pb::EncodedOrMember* __parent);

  // @@protoc_insertion_point(class_scope:pb.DataMember)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_extend_to();
  inline void clear_has_extend_to();
  inline void set_has_default_value();
  inline void clear_has_default_value();
  inline void set_has___parent();
  inline void clear_has___parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::DataType* type_;
  ::std::string* name_;
  ::pb::Variant* default_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> when_discriminant_;
  ::pb::EncodedOrMember* __parent_;
  bool extend_to_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static DataMember* default_instance_;
};
// -------------------------------------------------------------------

class EncodedMembers : public ::google::protobuf::Message {
 public:
  EncodedMembers();
  virtual ~EncodedMembers();

  EncodedMembers(const EncodedMembers& from);

  inline EncodedMembers& operator=(const EncodedMembers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncodedMembers& default_instance();

  void Swap(EncodedMembers* other);

  // implements Message ----------------------------------------------

  EncodedMembers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncodedMembers& from);
  void MergeFrom(const EncodedMembers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.EncodingSpecifics encoding_specifics = 1;
  inline bool has_encoding_specifics() const;
  inline void clear_encoding_specifics();
  static const int kEncodingSpecificsFieldNumber = 1;
  inline const ::pb::EncodingSpecifics& encoding_specifics() const;
  inline ::pb::EncodingSpecifics* mutable_encoding_specifics();
  inline ::pb::EncodingSpecifics* release_encoding_specifics();
  inline void set_allocated_encoding_specifics(::pb::EncodingSpecifics* encoding_specifics);

  // repeated .pb.__unique_ptr_EncodedOrMember members = 2;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::pb::__unique_ptr_EncodedOrMember& members(int index) const;
  inline ::pb::__unique_ptr_EncodedOrMember* mutable_members(int index);
  inline ::pb::__unique_ptr_EncodedOrMember* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_EncodedOrMember >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_EncodedOrMember >*
      mutable_members();

  // optional .pb.EncodedOrMember __parent = 3;
  inline bool has___parent() const;
  inline void clear___parent();
  static const int kParentFieldNumber = 3;
  inline const ::pb::EncodedOrMember& __parent() const;
  inline ::pb::EncodedOrMember* mutable___parent();
  inline ::pb::EncodedOrMember* release___parent();
  inline void set_allocated___parent(::pb::EncodedOrMember* __parent);

  // @@protoc_insertion_point(class_scope:pb.EncodedMembers)
 private:
  inline void set_has_encoding_specifics();
  inline void clear_has_encoding_specifics();
  inline void set_has___parent();
  inline void clear_has___parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::EncodingSpecifics* encoding_specifics_;
  ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_EncodedOrMember > members_;
  ::pb::EncodedOrMember* __parent_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static EncodedMembers* default_instance_;
};
// -------------------------------------------------------------------

class Structure : public ::google::protobuf::Message {
 public:
  Structure();
  virtual ~Structure();

  Structure(const Structure& from);

  inline Structure& operator=(const Structure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Structure& default_instance();

  void Swap(Structure* other);

  // implements Message ----------------------------------------------

  Structure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Structure& from);
  void MergeFrom(const Structure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Structure_DECLTYPE DECLTYPE;
  static const DECLTYPE ENCODING = Structure_DECLTYPE_ENCODING;
  static const DECLTYPE IDL = Structure_DECLTYPE_IDL;
  static const DECLTYPE MAPPING = Structure_DECLTYPE_MAPPING;
  static inline bool DECLTYPE_IsValid(int value) {
    return Structure_DECLTYPE_IsValid(value);
  }
  static const DECLTYPE DECLTYPE_MIN =
    Structure_DECLTYPE_DECLTYPE_MIN;
  static const DECLTYPE DECLTYPE_MAX =
    Structure_DECLTYPE_DECLTYPE_MAX;
  static const int DECLTYPE_ARRAYSIZE =
    Structure_DECLTYPE_DECLTYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DECLTYPE_descriptor() {
    return Structure_DECLTYPE_descriptor();
  }
  static inline const ::std::string& DECLTYPE_Name(DECLTYPE value) {
    return Structure_DECLTYPE_Name(value);
  }
  static inline bool DECLTYPE_Parse(const ::std::string& name,
      DECLTYPE* value) {
    return Structure_DECLTYPE_Parse(name, value);
  }

  typedef Structure_TYPE TYPE;
  static const TYPE DISCRIMINATED_UNION = Structure_TYPE_DISCRIMINATED_UNION;
  static const TYPE RPC = Structure_TYPE_RPC;
  static const TYPE STRUCT = Structure_TYPE_STRUCT;
  static inline bool TYPE_IsValid(int value) {
    return Structure_TYPE_IsValid(value);
  }
  static const TYPE TYPE_MIN =
    Structure_TYPE_TYPE_MIN;
  static const TYPE TYPE_MAX =
    Structure_TYPE_TYPE_MAX;
  static const int TYPE_ARRAYSIZE =
    Structure_TYPE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TYPE_descriptor() {
    return Structure_TYPE_descriptor();
  }
  static inline const ::std::string& TYPE_Name(TYPE value) {
    return Structure_TYPE_Name(value);
  }
  static inline bool TYPE_Parse(const ::std::string& name,
      TYPE* value) {
    return Structure_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pb.Structure.DECLTYPE decl_type = 1;
  inline bool has_decl_type() const;
  inline void clear_decl_type();
  static const int kDeclTypeFieldNumber = 1;
  inline ::pb::Structure_DECLTYPE decl_type() const;
  inline void set_decl_type(::pb::Structure_DECLTYPE value);

  // optional .pb.Structure.TYPE type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::pb::Structure_TYPE type() const;
  inline void set_type(::pb::Structure_TYPE value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string discriminant = 4;
  inline bool has_discriminant() const;
  inline void clear_discriminant();
  static const int kDiscriminantFieldNumber = 4;
  inline const ::std::string& discriminant() const;
  inline void set_discriminant(const ::std::string& value);
  inline void set_discriminant(const char* value);
  inline void set_discriminant(const char* value, size_t size);
  inline ::std::string* mutable_discriminant();
  inline ::std::string* release_discriminant();
  inline void set_allocated_discriminant(::std::string* discriminant);

  // optional string inherited_from = 5;
  inline bool has_inherited_from() const;
  inline void clear_inherited_from();
  static const int kInheritedFromFieldNumber = 5;
  inline const ::std::string& inherited_from() const;
  inline void set_inherited_from(const ::std::string& value);
  inline void set_inherited_from(const char* value);
  inline void set_inherited_from(const char* value, size_t size);
  inline ::std::string* mutable_inherited_from();
  inline ::std::string* release_inherited_from();
  inline void set_allocated_inherited_from(::std::string* inherited_from);

  // optional .pb.EncodedMembers __parent = 6;
  inline bool has___parent() const;
  inline void clear___parent();
  static const int kParentFieldNumber = 6;
  inline const ::pb::EncodedMembers& __parent() const;
  inline ::pb::EncodedMembers* mutable___parent();
  inline ::pb::EncodedMembers* release___parent();
  inline void set_allocated___parent(::pb::EncodedMembers* __parent);

  // @@protoc_insertion_point(class_scope:pb.Structure)
 private:
  inline void set_has_decl_type();
  inline void clear_has_decl_type();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_discriminant();
  inline void clear_has_discriminant();
  inline void set_has_inherited_from();
  inline void clear_has_inherited_from();
  inline void set_has___parent();
  inline void clear_has___parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int decl_type_;
  int type_;
  ::std::string* name_;
  ::std::string* discriminant_;
  ::std::string* inherited_from_;
  ::pb::EncodedMembers* __parent_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static Structure* default_instance_;
};
// -------------------------------------------------------------------

class Typedef : public ::google::protobuf::Message {
 public:
  Typedef();
  virtual ~Typedef();

  Typedef(const Typedef& from);

  inline Typedef& operator=(const Typedef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Typedef& default_instance();

  void Swap(Typedef* other);

  // implements Message ----------------------------------------------

  Typedef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Typedef& from);
  void MergeFrom(const Typedef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.Location location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::pb::Location& location() const;
  inline ::pb::Location* mutable_location();
  inline ::pb::Location* release_location();
  inline void set_allocated_location(::pb::Location* location);

  // optional .pb.DataType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::pb::DataType& type() const;
  inline ::pb::DataType* mutable_type();
  inline ::pb::DataType* release_type();
  inline void set_allocated_type(::pb::DataType* type);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:pb.Typedef)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::Location* location_;
  ::pb::DataType* type_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static Typedef* default_instance_;
};
// -------------------------------------------------------------------

class Root : public ::google::protobuf::Message {
 public:
  Root();
  virtual ~Root();

  Root(const Root& from);

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Root& default_instance();

  void Swap(Root* other);

  // implements Message ----------------------------------------------

  Root* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Root& from);
  void MergeFrom(const Root& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Typedef typedefs = 1;
  inline int typedefs_size() const;
  inline void clear_typedefs();
  static const int kTypedefsFieldNumber = 1;
  inline const ::pb::Typedef& typedefs(int index) const;
  inline ::pb::Typedef* mutable_typedefs(int index);
  inline ::pb::Typedef* add_typedefs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Typedef >&
      typedefs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Typedef >*
      mutable_typedefs();

  // repeated .pb.__unique_ptr_Structure structures = 2;
  inline int structures_size() const;
  inline void clear_structures();
  static const int kStructuresFieldNumber = 2;
  inline const ::pb::__unique_ptr_Structure& structures(int index) const;
  inline ::pb::__unique_ptr_Structure* mutable_structures(int index);
  inline ::pb::__unique_ptr_Structure* add_structures();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_Structure >&
      structures() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_Structure >*
      mutable_structures();

  // repeated sint32 packed_var_ints = 3 [packed = true];
  inline int packed_var_ints_size() const;
  inline void clear_packed_var_ints();
  static const int kPackedVarIntsFieldNumber = 3;
  inline ::google::protobuf::int32 packed_var_ints(int index) const;
  inline void set_packed_var_ints(int index, ::google::protobuf::int32 value);
  inline void add_packed_var_ints(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      packed_var_ints() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_packed_var_ints();

  // repeated double packed_doubles = 4 [packed = true];
  inline int packed_doubles_size() const;
  inline void clear_packed_doubles();
  static const int kPackedDoublesFieldNumber = 4;
  inline double packed_doubles(int index) const;
  inline void set_packed_doubles(int index, double value);
  inline void add_packed_doubles(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      packed_doubles() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_packed_doubles();

  // repeated string unpacked_strings = 5;
  inline int unpacked_strings_size() const;
  inline void clear_unpacked_strings();
  static const int kUnpackedStringsFieldNumber = 5;
  inline const ::std::string& unpacked_strings(int index) const;
  inline ::std::string* mutable_unpacked_strings(int index);
  inline void set_unpacked_strings(int index, const ::std::string& value);
  inline void set_unpacked_strings(int index, const char* value);
  inline void set_unpacked_strings(int index, const char* value, size_t size);
  inline ::std::string* add_unpacked_strings();
  inline void add_unpacked_strings(const ::std::string& value);
  inline void add_unpacked_strings(const char* value);
  inline void add_unpacked_strings(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unpacked_strings() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unpacked_strings();

  // @@protoc_insertion_point(class_scope:pb.Root)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pb::Typedef > typedefs_;
  ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_Structure > structures_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > packed_var_ints_;
  mutable int _packed_var_ints_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > packed_doubles_;
  mutable int _packed_doubles_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unpacked_strings_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static Root* default_instance_;
};
// -------------------------------------------------------------------

class __unique_ptr_DataType : public ::google::protobuf::Message {
 public:
  __unique_ptr_DataType();
  virtual ~__unique_ptr_DataType();

  __unique_ptr_DataType(const __unique_ptr_DataType& from);

  inline __unique_ptr_DataType& operator=(const __unique_ptr_DataType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const __unique_ptr_DataType& default_instance();

  void Swap(__unique_ptr_DataType* other);

  // implements Message ----------------------------------------------

  __unique_ptr_DataType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const __unique_ptr_DataType& from);
  void MergeFrom(const __unique_ptr_DataType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef __unique_ptr_DataType_Discriminator Discriminator;
  static const Discriminator OPT_DataType = __unique_ptr_DataType_Discriminator_OPT_DataType;
  static const Discriminator OPT_nullptr = __unique_ptr_DataType_Discriminator_OPT_nullptr;
  static inline bool Discriminator_IsValid(int value) {
    return __unique_ptr_DataType_Discriminator_IsValid(value);
  }
  static const Discriminator Discriminator_MIN =
    __unique_ptr_DataType_Discriminator_Discriminator_MIN;
  static const Discriminator Discriminator_MAX =
    __unique_ptr_DataType_Discriminator_Discriminator_MAX;
  static const int Discriminator_ARRAYSIZE =
    __unique_ptr_DataType_Discriminator_Discriminator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Discriminator_descriptor() {
    return __unique_ptr_DataType_Discriminator_descriptor();
  }
  static inline const ::std::string& Discriminator_Name(Discriminator value) {
    return __unique_ptr_DataType_Discriminator_Name(value);
  }
  static inline bool Discriminator_Parse(const ::std::string& name,
      Discriminator* value) {
    return __unique_ptr_DataType_Discriminator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pb.__unique_ptr_DataType.Discriminator discriminator = 1;
  inline bool has_discriminator() const;
  inline void clear_discriminator();
  static const int kDiscriminatorFieldNumber = 1;
  inline ::pb::__unique_ptr_DataType_Discriminator discriminator() const;
  inline void set_discriminator(::pb::__unique_ptr_DataType_Discriminator value);

  // optional .pb.DataType du_data_type = 2;
  inline bool has_du_data_type() const;
  inline void clear_du_data_type();
  static const int kDuDataTypeFieldNumber = 2;
  inline const ::pb::DataType& du_data_type() const;
  inline ::pb::DataType* mutable_du_data_type();
  inline ::pb::DataType* release_du_data_type();
  inline void set_allocated_du_data_type(::pb::DataType* du_data_type);

  // @@protoc_insertion_point(class_scope:pb.__unique_ptr_DataType)
 private:
  inline void set_has_discriminator();
  inline void clear_has_discriminator();
  inline void set_has_du_data_type();
  inline void clear_has_du_data_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::DataType* du_data_type_;
  int discriminator_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static __unique_ptr_DataType* default_instance_;
};
// -------------------------------------------------------------------

class __unique_ptr_EncodedOrMember : public ::google::protobuf::Message {
 public:
  __unique_ptr_EncodedOrMember();
  virtual ~__unique_ptr_EncodedOrMember();

  __unique_ptr_EncodedOrMember(const __unique_ptr_EncodedOrMember& from);

  inline __unique_ptr_EncodedOrMember& operator=(const __unique_ptr_EncodedOrMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const __unique_ptr_EncodedOrMember& default_instance();

  void Swap(__unique_ptr_EncodedOrMember* other);

  // implements Message ----------------------------------------------

  __unique_ptr_EncodedOrMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const __unique_ptr_EncodedOrMember& from);
  void MergeFrom(const __unique_ptr_EncodedOrMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef __unique_ptr_EncodedOrMember_Discriminator Discriminator;
  static const Discriminator OPT_DataMember = __unique_ptr_EncodedOrMember_Discriminator_OPT_DataMember;
  static const Discriminator OPT_EncodedMembers = __unique_ptr_EncodedOrMember_Discriminator_OPT_EncodedMembers;
  static const Discriminator OPT_EncodedOrMember = __unique_ptr_EncodedOrMember_Discriminator_OPT_EncodedOrMember;
  static const Discriminator OPT_nullptr = __unique_ptr_EncodedOrMember_Discriminator_OPT_nullptr;
  static inline bool Discriminator_IsValid(int value) {
    return __unique_ptr_EncodedOrMember_Discriminator_IsValid(value);
  }
  static const Discriminator Discriminator_MIN =
    __unique_ptr_EncodedOrMember_Discriminator_Discriminator_MIN;
  static const Discriminator Discriminator_MAX =
    __unique_ptr_EncodedOrMember_Discriminator_Discriminator_MAX;
  static const int Discriminator_ARRAYSIZE =
    __unique_ptr_EncodedOrMember_Discriminator_Discriminator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Discriminator_descriptor() {
    return __unique_ptr_EncodedOrMember_Discriminator_descriptor();
  }
  static inline const ::std::string& Discriminator_Name(Discriminator value) {
    return __unique_ptr_EncodedOrMember_Discriminator_Name(value);
  }
  static inline bool Discriminator_Parse(const ::std::string& name,
      Discriminator* value) {
    return __unique_ptr_EncodedOrMember_Discriminator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pb.__unique_ptr_EncodedOrMember.Discriminator discriminator = 1;
  inline bool has_discriminator() const;
  inline void clear_discriminator();
  static const int kDiscriminatorFieldNumber = 1;
  inline ::pb::__unique_ptr_EncodedOrMember_Discriminator discriminator() const;
  inline void set_discriminator(::pb::__unique_ptr_EncodedOrMember_Discriminator value);

  // optional .pb.DataMember du_data_member = 2;
  inline bool has_du_data_member() const;
  inline void clear_du_data_member();
  static const int kDuDataMemberFieldNumber = 2;
  inline const ::pb::DataMember& du_data_member() const;
  inline ::pb::DataMember* mutable_du_data_member();
  inline ::pb::DataMember* release_du_data_member();
  inline void set_allocated_du_data_member(::pb::DataMember* du_data_member);

  // optional .pb.EncodedMembers du_encoded_members = 3;
  inline bool has_du_encoded_members() const;
  inline void clear_du_encoded_members();
  static const int kDuEncodedMembersFieldNumber = 3;
  inline const ::pb::EncodedMembers& du_encoded_members() const;
  inline ::pb::EncodedMembers* mutable_du_encoded_members();
  inline ::pb::EncodedMembers* release_du_encoded_members();
  inline void set_allocated_du_encoded_members(::pb::EncodedMembers* du_encoded_members);

  // optional .pb.EncodedOrMember du_encoded_or_member = 4;
  inline bool has_du_encoded_or_member() const;
  inline void clear_du_encoded_or_member();
  static const int kDuEncodedOrMemberFieldNumber = 4;
  inline const ::pb::EncodedOrMember& du_encoded_or_member() const;
  inline ::pb::EncodedOrMember* mutable_du_encoded_or_member();
  inline ::pb::EncodedOrMember* release_du_encoded_or_member();
  inline void set_allocated_du_encoded_or_member(::pb::EncodedOrMember* du_encoded_or_member);

  // @@protoc_insertion_point(class_scope:pb.__unique_ptr_EncodedOrMember)
 private:
  inline void set_has_discriminator();
  inline void clear_has_discriminator();
  inline void set_has_du_data_member();
  inline void clear_has_du_data_member();
  inline void set_has_du_encoded_members();
  inline void clear_has_du_encoded_members();
  inline void set_has_du_encoded_or_member();
  inline void clear_has_du_encoded_or_member();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::DataMember* du_data_member_;
  ::pb::EncodedMembers* du_encoded_members_;
  ::pb::EncodedOrMember* du_encoded_or_member_;
  int discriminator_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static __unique_ptr_EncodedOrMember* default_instance_;
};
// -------------------------------------------------------------------

class __unique_ptr_Structure : public ::google::protobuf::Message {
 public:
  __unique_ptr_Structure();
  virtual ~__unique_ptr_Structure();

  __unique_ptr_Structure(const __unique_ptr_Structure& from);

  inline __unique_ptr_Structure& operator=(const __unique_ptr_Structure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const __unique_ptr_Structure& default_instance();

  void Swap(__unique_ptr_Structure* other);

  // implements Message ----------------------------------------------

  __unique_ptr_Structure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const __unique_ptr_Structure& from);
  void MergeFrom(const __unique_ptr_Structure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef __unique_ptr_Structure_Discriminator Discriminator;
  static const Discriminator OPT_Structure = __unique_ptr_Structure_Discriminator_OPT_Structure;
  static const Discriminator OPT_nullptr = __unique_ptr_Structure_Discriminator_OPT_nullptr;
  static inline bool Discriminator_IsValid(int value) {
    return __unique_ptr_Structure_Discriminator_IsValid(value);
  }
  static const Discriminator Discriminator_MIN =
    __unique_ptr_Structure_Discriminator_Discriminator_MIN;
  static const Discriminator Discriminator_MAX =
    __unique_ptr_Structure_Discriminator_Discriminator_MAX;
  static const int Discriminator_ARRAYSIZE =
    __unique_ptr_Structure_Discriminator_Discriminator_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Discriminator_descriptor() {
    return __unique_ptr_Structure_Discriminator_descriptor();
  }
  static inline const ::std::string& Discriminator_Name(Discriminator value) {
    return __unique_ptr_Structure_Discriminator_Name(value);
  }
  static inline bool Discriminator_Parse(const ::std::string& name,
      Discriminator* value) {
    return __unique_ptr_Structure_Discriminator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pb.__unique_ptr_Structure.Discriminator discriminator = 1;
  inline bool has_discriminator() const;
  inline void clear_discriminator();
  static const int kDiscriminatorFieldNumber = 1;
  inline ::pb::__unique_ptr_Structure_Discriminator discriminator() const;
  inline void set_discriminator(::pb::__unique_ptr_Structure_Discriminator value);

  // optional .pb.Structure du_structure = 2;
  inline bool has_du_structure() const;
  inline void clear_du_structure();
  static const int kDuStructureFieldNumber = 2;
  inline const ::pb::Structure& du_structure() const;
  inline ::pb::Structure* mutable_du_structure();
  inline ::pb::Structure* release_du_structure();
  inline void set_allocated_du_structure(::pb::Structure* du_structure);

  // @@protoc_insertion_point(class_scope:pb.__unique_ptr_Structure)
 private:
  inline void set_has_discriminator();
  inline void clear_has_discriminator();
  inline void set_has_du_structure();
  inline void clear_has_du_structure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pb::Structure* du_structure_;
  int discriminator_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static __unique_ptr_Structure* default_instance_;
};
// -------------------------------------------------------------------

class map_string_Variant : public ::google::protobuf::Message {
 public:
  map_string_Variant();
  virtual ~map_string_Variant();

  map_string_Variant(const map_string_Variant& from);

  inline map_string_Variant& operator=(const map_string_Variant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const map_string_Variant& default_instance();

  void Swap(map_string_Variant* other);

  // implements Message ----------------------------------------------

  map_string_Variant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const map_string_Variant& from);
  void MergeFrom(const map_string_Variant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .pb.Variant value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::pb::Variant& value() const;
  inline ::pb::Variant* mutable_value();
  inline ::pb::Variant* release_value();
  inline void set_allocated_value(::pb::Variant* value);

  // @@protoc_insertion_point(class_scope:pb.map_string_Variant)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::pb::Variant* value_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static map_string_Variant* default_instance_;
};
// -------------------------------------------------------------------

class map_string_uint32 : public ::google::protobuf::Message {
 public:
  map_string_uint32();
  virtual ~map_string_uint32();

  map_string_uint32(const map_string_uint32& from);

  inline map_string_uint32& operator=(const map_string_uint32& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const map_string_uint32& default_instance();

  void Swap(map_string_uint32* other);

  // implements Message ----------------------------------------------

  map_string_uint32* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const map_string_uint32& from);
  void MergeFrom(const map_string_uint32& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.map_string_uint32)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::google::protobuf::uint32 value_;
  friend void  protobuf_AddDesc_output_2eproto();
  friend void protobuf_AssignDesc_output_2eproto();
  friend void protobuf_ShutdownFile_output_2eproto();

  void InitAsDefaultInstance();
  static map_string_uint32* default_instance_;
};
// ===================================================================


// ===================================================================

// Limit

// optional bool inclusive = 1;
inline bool Limit::has_inclusive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limit::set_has_inclusive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limit::clear_has_inclusive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limit::clear_inclusive() {
  inclusive_ = false;
  clear_has_inclusive();
}
inline bool Limit::inclusive() const {
  // @@protoc_insertion_point(field_get:pb.Limit.inclusive)
  return inclusive_;
}
inline void Limit::set_inclusive(bool value) {
  set_has_inclusive();
  inclusive_ = value;
  // @@protoc_insertion_point(field_set:pb.Limit.inclusive)
}

// optional double value = 2;
inline bool Limit::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limit::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limit::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limit::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Limit::value() const {
  // @@protoc_insertion_point(field_get:pb.Limit.value)
  return value_;
}
inline void Limit::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.Limit.value)
}

// -------------------------------------------------------------------

// Location

// optional string file_name = 1;
inline bool Location::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& Location::file_name() const {
  // @@protoc_insertion_point(field_get:pb.Location.file_name)
  return *file_name_;
}
inline void Location::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Location.file_name)
}
inline void Location::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Location.file_name)
}
inline void Location::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Location.file_name)
}
inline ::std::string* Location::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Location.file_name)
  return file_name_;
}
inline ::std::string* Location::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Location::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Location.file_name)
}

// optional sint32 line_number = 2;
inline bool Location::has_line_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_line_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 Location::line_number() const {
  // @@protoc_insertion_point(field_get:pb.Location.line_number)
  return line_number_;
}
inline void Location::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
  // @@protoc_insertion_point(field_set:pb.Location.line_number)
}

// -------------------------------------------------------------------

// CharacterRange

// optional uint32 from = 1;
inline bool CharacterRange::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharacterRange::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharacterRange::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharacterRange::clear_from() {
  from_ = 0u;
  clear_has_from();
}
inline ::google::protobuf::uint32 CharacterRange::from() const {
  // @@protoc_insertion_point(field_get:pb.CharacterRange.from)
  return from_;
}
inline void CharacterRange::set_from(::google::protobuf::uint32 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:pb.CharacterRange.from)
}

// optional uint32 to = 2;
inline bool CharacterRange::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharacterRange::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharacterRange::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharacterRange::clear_to() {
  to_ = 0u;
  clear_has_to();
}
inline ::google::protobuf::uint32 CharacterRange::to() const {
  // @@protoc_insertion_point(field_get:pb.CharacterRange.to)
  return to_;
}
inline void CharacterRange::set_to(::google::protobuf::uint32 value) {
  set_has_to();
  to_ = value;
  // @@protoc_insertion_point(field_set:pb.CharacterRange.to)
}

// -------------------------------------------------------------------

// CharacterSet

// repeated .pb.CharacterRange ranges = 1;
inline int CharacterSet::ranges_size() const {
  return ranges_.size();
}
inline void CharacterSet::clear_ranges() {
  ranges_.Clear();
}
inline const ::pb::CharacterRange& CharacterSet::ranges(int index) const {
  // @@protoc_insertion_point(field_get:pb.CharacterSet.ranges)
  return ranges_.Get(index);
}
inline ::pb::CharacterRange* CharacterSet::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:pb.CharacterSet.ranges)
  return ranges_.Mutable(index);
}
inline ::pb::CharacterRange* CharacterSet::add_ranges() {
  // @@protoc_insertion_point(field_add:pb.CharacterSet.ranges)
  return ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CharacterRange >&
CharacterSet::ranges() const {
  // @@protoc_insertion_point(field_list:pb.CharacterSet.ranges)
  return ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CharacterRange >*
CharacterSet::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:pb.CharacterSet.ranges)
  return &ranges_;
}

// -------------------------------------------------------------------

// Variant

// optional .pb.Variant.KIND kind = 1;
inline bool Variant::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Variant::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Variant::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Variant::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::pb::Variant_KIND Variant::kind() const {
  // @@protoc_insertion_point(field_get:pb.Variant.kind)
  return static_cast< ::pb::Variant_KIND >(kind_);
}
inline void Variant::set_kind(::pb::Variant_KIND value) {
  assert(::pb::Variant_KIND_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:pb.Variant.kind)
}

// optional double number_value = 2;
inline bool Variant::has_number_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Variant::set_has_number_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Variant::clear_has_number_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Variant::clear_number_value() {
  number_value_ = 0;
  clear_has_number_value();
}
inline double Variant::number_value() const {
  // @@protoc_insertion_point(field_get:pb.Variant.number_value)
  return number_value_;
}
inline void Variant::set_number_value(double value) {
  set_has_number_value();
  number_value_ = value;
  // @@protoc_insertion_point(field_set:pb.Variant.number_value)
}

// optional string string_value = 3;
inline bool Variant::has_string_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Variant::set_has_string_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Variant::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Variant::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& Variant::string_value() const {
  // @@protoc_insertion_point(field_get:pb.Variant.string_value)
  return *string_value_;
}
inline void Variant::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Variant.string_value)
}
inline void Variant::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Variant.string_value)
}
inline void Variant::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Variant.string_value)
}
inline ::std::string* Variant::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Variant.string_value)
  return string_value_;
}
inline ::std::string* Variant::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Variant::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Variant.string_value)
}

// -------------------------------------------------------------------

// DataType

// optional .pb.DataType.KIND kind = 1;
inline bool DataType::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataType::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataType::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataType::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::pb::DataType_KIND DataType::kind() const {
  // @@protoc_insertion_point(field_get:pb.DataType.kind)
  return static_cast< ::pb::DataType_KIND >(kind_);
}
inline void DataType::set_kind(::pb::DataType_KIND value) {
  assert(::pb::DataType_KIND_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:pb.DataType.kind)
}

// optional string name = 2;
inline bool DataType::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataType::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataType::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataType::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DataType::name() const {
  // @@protoc_insertion_point(field_get:pb.DataType.name)
  return *name_;
}
inline void DataType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.DataType.name)
}
inline void DataType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.DataType.name)
}
inline void DataType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.DataType.name)
}
inline ::std::string* DataType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.DataType.name)
  return name_;
}
inline ::std::string* DataType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.name)
}

// optional string mapping_name = 3;
inline bool DataType::has_mapping_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataType::set_has_mapping_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataType::clear_has_mapping_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataType::clear_mapping_name() {
  if (mapping_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapping_name_->clear();
  }
  clear_has_mapping_name();
}
inline const ::std::string& DataType::mapping_name() const {
  // @@protoc_insertion_point(field_get:pb.DataType.mapping_name)
  return *mapping_name_;
}
inline void DataType::set_mapping_name(const ::std::string& value) {
  set_has_mapping_name();
  if (mapping_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapping_name_ = new ::std::string;
  }
  mapping_name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.DataType.mapping_name)
}
inline void DataType::set_mapping_name(const char* value) {
  set_has_mapping_name();
  if (mapping_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapping_name_ = new ::std::string;
  }
  mapping_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.DataType.mapping_name)
}
inline void DataType::set_mapping_name(const char* value, size_t size) {
  set_has_mapping_name();
  if (mapping_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapping_name_ = new ::std::string;
  }
  mapping_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.DataType.mapping_name)
}
inline ::std::string* DataType::mutable_mapping_name() {
  set_has_mapping_name();
  if (mapping_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapping_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.DataType.mapping_name)
  return mapping_name_;
}
inline ::std::string* DataType::release_mapping_name() {
  clear_has_mapping_name();
  if (mapping_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapping_name_;
    mapping_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataType::set_allocated_mapping_name(::std::string* mapping_name) {
  if (mapping_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapping_name_;
  }
  if (mapping_name) {
    set_has_mapping_name();
    mapping_name_ = mapping_name;
  } else {
    clear_has_mapping_name();
    mapping_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.mapping_name)
}

// optional string encoding_name = 4;
inline bool DataType::has_encoding_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataType::set_has_encoding_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataType::clear_has_encoding_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataType::clear_encoding_name() {
  if (encoding_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoding_name_->clear();
  }
  clear_has_encoding_name();
}
inline const ::std::string& DataType::encoding_name() const {
  // @@protoc_insertion_point(field_get:pb.DataType.encoding_name)
  return *encoding_name_;
}
inline void DataType::set_encoding_name(const ::std::string& value) {
  set_has_encoding_name();
  if (encoding_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoding_name_ = new ::std::string;
  }
  encoding_name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.DataType.encoding_name)
}
inline void DataType::set_encoding_name(const char* value) {
  set_has_encoding_name();
  if (encoding_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoding_name_ = new ::std::string;
  }
  encoding_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.DataType.encoding_name)
}
inline void DataType::set_encoding_name(const char* value, size_t size) {
  set_has_encoding_name();
  if (encoding_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoding_name_ = new ::std::string;
  }
  encoding_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.DataType.encoding_name)
}
inline ::std::string* DataType::mutable_encoding_name() {
  set_has_encoding_name();
  if (encoding_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoding_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.DataType.encoding_name)
  return encoding_name_;
}
inline ::std::string* DataType::release_encoding_name() {
  clear_has_encoding_name();
  if (encoding_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encoding_name_;
    encoding_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataType::set_allocated_encoding_name(::std::string* encoding_name) {
  if (encoding_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encoding_name_;
  }
  if (encoding_name) {
    set_has_encoding_name();
    encoding_name_ = encoding_name;
  } else {
    clear_has_encoding_name();
    encoding_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.encoding_name)
}

// optional .pb.__unique_ptr_DataType key_type = 5;
inline bool DataType::has_key_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataType::set_has_key_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataType::clear_has_key_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataType::clear_key_type() {
  if (key_type_ != NULL) key_type_->::pb::__unique_ptr_DataType::Clear();
  clear_has_key_type();
}
inline const ::pb::__unique_ptr_DataType& DataType::key_type() const {
  // @@protoc_insertion_point(field_get:pb.DataType.key_type)
  return key_type_ != NULL ? *key_type_ : *default_instance_->key_type_;
}
inline ::pb::__unique_ptr_DataType* DataType::mutable_key_type() {
  set_has_key_type();
  if (key_type_ == NULL) key_type_ = new ::pb::__unique_ptr_DataType;
  // @@protoc_insertion_point(field_mutable:pb.DataType.key_type)
  return key_type_;
}
inline ::pb::__unique_ptr_DataType* DataType::release_key_type() {
  clear_has_key_type();
  ::pb::__unique_ptr_DataType* temp = key_type_;
  key_type_ = NULL;
  return temp;
}
inline void DataType::set_allocated_key_type(::pb::__unique_ptr_DataType* key_type) {
  delete key_type_;
  key_type_ = key_type;
  if (key_type) {
    set_has_key_type();
  } else {
    clear_has_key_type();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.key_type)
}

// optional .pb.__unique_ptr_DataType param_type = 6;
inline bool DataType::has_param_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataType::set_has_param_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataType::clear_has_param_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataType::clear_param_type() {
  if (param_type_ != NULL) param_type_->::pb::__unique_ptr_DataType::Clear();
  clear_has_param_type();
}
inline const ::pb::__unique_ptr_DataType& DataType::param_type() const {
  // @@protoc_insertion_point(field_get:pb.DataType.param_type)
  return param_type_ != NULL ? *param_type_ : *default_instance_->param_type_;
}
inline ::pb::__unique_ptr_DataType* DataType::mutable_param_type() {
  set_has_param_type();
  if (param_type_ == NULL) param_type_ = new ::pb::__unique_ptr_DataType;
  // @@protoc_insertion_point(field_mutable:pb.DataType.param_type)
  return param_type_;
}
inline ::pb::__unique_ptr_DataType* DataType::release_param_type() {
  clear_has_param_type();
  ::pb::__unique_ptr_DataType* temp = param_type_;
  param_type_ = NULL;
  return temp;
}
inline void DataType::set_allocated_param_type(::pb::__unique_ptr_DataType* param_type) {
  delete param_type_;
  param_type_ = param_type;
  if (param_type) {
    set_has_param_type();
  } else {
    clear_has_param_type();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.param_type)
}

// optional .pb.Limit low_limit = 7;
inline bool DataType::has_low_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataType::set_has_low_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataType::clear_has_low_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataType::clear_low_limit() {
  if (low_limit_ != NULL) low_limit_->::pb::Limit::Clear();
  clear_has_low_limit();
}
inline const ::pb::Limit& DataType::low_limit() const {
  // @@protoc_insertion_point(field_get:pb.DataType.low_limit)
  return low_limit_ != NULL ? *low_limit_ : *default_instance_->low_limit_;
}
inline ::pb::Limit* DataType::mutable_low_limit() {
  set_has_low_limit();
  if (low_limit_ == NULL) low_limit_ = new ::pb::Limit;
  // @@protoc_insertion_point(field_mutable:pb.DataType.low_limit)
  return low_limit_;
}
inline ::pb::Limit* DataType::release_low_limit() {
  clear_has_low_limit();
  ::pb::Limit* temp = low_limit_;
  low_limit_ = NULL;
  return temp;
}
inline void DataType::set_allocated_low_limit(::pb::Limit* low_limit) {
  delete low_limit_;
  low_limit_ = low_limit;
  if (low_limit) {
    set_has_low_limit();
  } else {
    clear_has_low_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.low_limit)
}

// optional .pb.Limit high_limit = 8;
inline bool DataType::has_high_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataType::set_has_high_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataType::clear_has_high_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataType::clear_high_limit() {
  if (high_limit_ != NULL) high_limit_->::pb::Limit::Clear();
  clear_has_high_limit();
}
inline const ::pb::Limit& DataType::high_limit() const {
  // @@protoc_insertion_point(field_get:pb.DataType.high_limit)
  return high_limit_ != NULL ? *high_limit_ : *default_instance_->high_limit_;
}
inline ::pb::Limit* DataType::mutable_high_limit() {
  set_has_high_limit();
  if (high_limit_ == NULL) high_limit_ = new ::pb::Limit;
  // @@protoc_insertion_point(field_mutable:pb.DataType.high_limit)
  return high_limit_;
}
inline ::pb::Limit* DataType::release_high_limit() {
  clear_has_high_limit();
  ::pb::Limit* temp = high_limit_;
  high_limit_ = NULL;
  return temp;
}
inline void DataType::set_allocated_high_limit(::pb::Limit* high_limit) {
  delete high_limit_;
  high_limit_ = high_limit;
  if (high_limit) {
    set_has_high_limit();
  } else {
    clear_has_high_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.high_limit)
}

// optional double fixed_precision = 9;
inline bool DataType::has_fixed_precision() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataType::set_has_fixed_precision() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataType::clear_has_fixed_precision() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataType::clear_fixed_precision() {
  fixed_precision_ = 0;
  clear_has_fixed_precision();
}
inline double DataType::fixed_precision() const {
  // @@protoc_insertion_point(field_get:pb.DataType.fixed_precision)
  return fixed_precision_;
}
inline void DataType::set_fixed_precision(double value) {
  set_has_fixed_precision();
  fixed_precision_ = value;
  // @@protoc_insertion_point(field_set:pb.DataType.fixed_precision)
}

// optional uint32 floating_significand_bits = 10;
inline bool DataType::has_floating_significand_bits() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataType::set_has_floating_significand_bits() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataType::clear_has_floating_significand_bits() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataType::clear_floating_significand_bits() {
  floating_significand_bits_ = 0u;
  clear_has_floating_significand_bits();
}
inline ::google::protobuf::uint32 DataType::floating_significand_bits() const {
  // @@protoc_insertion_point(field_get:pb.DataType.floating_significand_bits)
  return floating_significand_bits_;
}
inline void DataType::set_floating_significand_bits(::google::protobuf::uint32 value) {
  set_has_floating_significand_bits();
  floating_significand_bits_ = value;
  // @@protoc_insertion_point(field_set:pb.DataType.floating_significand_bits)
}

// optional uint32 floating_exponent_bits = 11;
inline bool DataType::has_floating_exponent_bits() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataType::set_has_floating_exponent_bits() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataType::clear_has_floating_exponent_bits() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataType::clear_floating_exponent_bits() {
  floating_exponent_bits_ = 0u;
  clear_has_floating_exponent_bits();
}
inline ::google::protobuf::uint32 DataType::floating_exponent_bits() const {
  // @@protoc_insertion_point(field_get:pb.DataType.floating_exponent_bits)
  return floating_exponent_bits_;
}
inline void DataType::set_floating_exponent_bits(::google::protobuf::uint32 value) {
  set_has_floating_exponent_bits();
  floating_exponent_bits_ = value;
  // @@protoc_insertion_point(field_set:pb.DataType.floating_exponent_bits)
}

// optional .pb.CharacterSet character_set = 12;
inline bool DataType::has_character_set() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataType::set_has_character_set() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataType::clear_has_character_set() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataType::clear_character_set() {
  if (character_set_ != NULL) character_set_->::pb::CharacterSet::Clear();
  clear_has_character_set();
}
inline const ::pb::CharacterSet& DataType::character_set() const {
  // @@protoc_insertion_point(field_get:pb.DataType.character_set)
  return character_set_ != NULL ? *character_set_ : *default_instance_->character_set_;
}
inline ::pb::CharacterSet* DataType::mutable_character_set() {
  set_has_character_set();
  if (character_set_ == NULL) character_set_ = new ::pb::CharacterSet;
  // @@protoc_insertion_point(field_mutable:pb.DataType.character_set)
  return character_set_;
}
inline ::pb::CharacterSet* DataType::release_character_set() {
  clear_has_character_set();
  ::pb::CharacterSet* temp = character_set_;
  character_set_ = NULL;
  return temp;
}
inline void DataType::set_allocated_character_set(::pb::CharacterSet* character_set) {
  delete character_set_;
  character_set_ = character_set;
  if (character_set) {
    set_has_character_set();
  } else {
    clear_has_character_set();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataType.character_set)
}

// optional uint32 string_min_size = 13;
inline bool DataType::has_string_min_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataType::set_has_string_min_size() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataType::clear_has_string_min_size() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataType::clear_string_min_size() {
  string_min_size_ = 0u;
  clear_has_string_min_size();
}
inline ::google::protobuf::uint32 DataType::string_min_size() const {
  // @@protoc_insertion_point(field_get:pb.DataType.string_min_size)
  return string_min_size_;
}
inline void DataType::set_string_min_size(::google::protobuf::uint32 value) {
  set_has_string_min_size();
  string_min_size_ = value;
  // @@protoc_insertion_point(field_set:pb.DataType.string_min_size)
}

// optional uint32 string_max_size = 14;
inline bool DataType::has_string_max_size() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataType::set_has_string_max_size() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataType::clear_has_string_max_size() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataType::clear_string_max_size() {
  string_max_size_ = 0u;
  clear_has_string_max_size();
}
inline ::google::protobuf::uint32 DataType::string_max_size() const {
  // @@protoc_insertion_point(field_get:pb.DataType.string_max_size)
  return string_max_size_;
}
inline void DataType::set_string_max_size(::google::protobuf::uint32 value) {
  set_has_string_max_size();
  string_max_size_ = value;
  // @@protoc_insertion_point(field_set:pb.DataType.string_max_size)
}

// repeated .pb.map_string_Variant encoding_attrs = 15;
inline int DataType::encoding_attrs_size() const {
  return encoding_attrs_.size();
}
inline void DataType::clear_encoding_attrs() {
  encoding_attrs_.Clear();
}
inline const ::pb::map_string_Variant& DataType::encoding_attrs(int index) const {
  // @@protoc_insertion_point(field_get:pb.DataType.encoding_attrs)
  return encoding_attrs_.Get(index);
}
inline ::pb::map_string_Variant* DataType::mutable_encoding_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.DataType.encoding_attrs)
  return encoding_attrs_.Mutable(index);
}
inline ::pb::map_string_Variant* DataType::add_encoding_attrs() {
  // @@protoc_insertion_point(field_add:pb.DataType.encoding_attrs)
  return encoding_attrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >&
DataType::encoding_attrs() const {
  // @@protoc_insertion_point(field_list:pb.DataType.encoding_attrs)
  return encoding_attrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >*
DataType::mutable_encoding_attrs() {
  // @@protoc_insertion_point(field_mutable_list:pb.DataType.encoding_attrs)
  return &encoding_attrs_;
}

// repeated .pb.map_string_Variant mapping_attrs = 16;
inline int DataType::mapping_attrs_size() const {
  return mapping_attrs_.size();
}
inline void DataType::clear_mapping_attrs() {
  mapping_attrs_.Clear();
}
inline const ::pb::map_string_Variant& DataType::mapping_attrs(int index) const {
  // @@protoc_insertion_point(field_get:pb.DataType.mapping_attrs)
  return mapping_attrs_.Get(index);
}
inline ::pb::map_string_Variant* DataType::mutable_mapping_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.DataType.mapping_attrs)
  return mapping_attrs_.Mutable(index);
}
inline ::pb::map_string_Variant* DataType::add_mapping_attrs() {
  // @@protoc_insertion_point(field_add:pb.DataType.mapping_attrs)
  return mapping_attrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >&
DataType::mapping_attrs() const {
  // @@protoc_insertion_point(field_list:pb.DataType.mapping_attrs)
  return mapping_attrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >*
DataType::mutable_mapping_attrs() {
  // @@protoc_insertion_point(field_mutable_list:pb.DataType.mapping_attrs)
  return &mapping_attrs_;
}

// repeated .pb.map_string_uint32 enum_values = 17;
inline int DataType::enum_values_size() const {
  return enum_values_.size();
}
inline void DataType::clear_enum_values() {
  enum_values_.Clear();
}
inline const ::pb::map_string_uint32& DataType::enum_values(int index) const {
  // @@protoc_insertion_point(field_get:pb.DataType.enum_values)
  return enum_values_.Get(index);
}
inline ::pb::map_string_uint32* DataType::mutable_enum_values(int index) {
  // @@protoc_insertion_point(field_mutable:pb.DataType.enum_values)
  return enum_values_.Mutable(index);
}
inline ::pb::map_string_uint32* DataType::add_enum_values() {
  // @@protoc_insertion_point(field_add:pb.DataType.enum_values)
  return enum_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_uint32 >&
DataType::enum_values() const {
  // @@protoc_insertion_point(field_list:pb.DataType.enum_values)
  return enum_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_uint32 >*
DataType::mutable_enum_values() {
  // @@protoc_insertion_point(field_mutable_list:pb.DataType.enum_values)
  return &enum_values_;
}

// -------------------------------------------------------------------

// EncodingSpecifics

// optional string name = 1;
inline bool EncodingSpecifics::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncodingSpecifics::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncodingSpecifics::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncodingSpecifics::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EncodingSpecifics::name() const {
  // @@protoc_insertion_point(field_get:pb.EncodingSpecifics.name)
  return *name_;
}
inline void EncodingSpecifics::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EncodingSpecifics.name)
}
inline void EncodingSpecifics::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EncodingSpecifics.name)
}
inline void EncodingSpecifics::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EncodingSpecifics.name)
}
inline ::std::string* EncodingSpecifics::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EncodingSpecifics.name)
  return name_;
}
inline ::std::string* EncodingSpecifics::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EncodingSpecifics::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EncodingSpecifics.name)
}

// repeated .pb.map_string_Variant attrs = 2;
inline int EncodingSpecifics::attrs_size() const {
  return attrs_.size();
}
inline void EncodingSpecifics::clear_attrs() {
  attrs_.Clear();
}
inline const ::pb::map_string_Variant& EncodingSpecifics::attrs(int index) const {
  // @@protoc_insertion_point(field_get:pb.EncodingSpecifics.attrs)
  return attrs_.Get(index);
}
inline ::pb::map_string_Variant* EncodingSpecifics::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EncodingSpecifics.attrs)
  return attrs_.Mutable(index);
}
inline ::pb::map_string_Variant* EncodingSpecifics::add_attrs() {
  // @@protoc_insertion_point(field_add:pb.EncodingSpecifics.attrs)
  return attrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >&
EncodingSpecifics::attrs() const {
  // @@protoc_insertion_point(field_list:pb.EncodingSpecifics.attrs)
  return attrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::map_string_Variant >*
EncodingSpecifics::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:pb.EncodingSpecifics.attrs)
  return &attrs_;
}

// -------------------------------------------------------------------

// EncodedOrMember

// optional .pb.Location location = 1;
inline bool EncodedOrMember::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncodedOrMember::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncodedOrMember::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncodedOrMember::clear_location() {
  if (location_ != NULL) location_->::pb::Location::Clear();
  clear_has_location();
}
inline const ::pb::Location& EncodedOrMember::location() const {
  // @@protoc_insertion_point(field_get:pb.EncodedOrMember.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::pb::Location* EncodedOrMember::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::pb::Location;
  // @@protoc_insertion_point(field_mutable:pb.EncodedOrMember.location)
  return location_;
}
inline ::pb::Location* EncodedOrMember::release_location() {
  clear_has_location();
  ::pb::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void EncodedOrMember::set_allocated_location(::pb::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EncodedOrMember.location)
}

// -------------------------------------------------------------------

// DataMember

// optional .pb.DataType type = 1;
inline bool DataMember::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMember::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMember::clear_type() {
  if (type_ != NULL) type_->::pb::DataType::Clear();
  clear_has_type();
}
inline const ::pb::DataType& DataMember::type() const {
  // @@protoc_insertion_point(field_get:pb.DataMember.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::pb::DataType* DataMember::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::pb::DataType;
  // @@protoc_insertion_point(field_mutable:pb.DataMember.type)
  return type_;
}
inline ::pb::DataType* DataMember::release_type() {
  clear_has_type();
  ::pb::DataType* temp = type_;
  type_ = NULL;
  return temp;
}
inline void DataMember::set_allocated_type(::pb::DataType* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataMember.type)
}

// optional string name = 2;
inline bool DataMember::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMember::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMember::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMember::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DataMember::name() const {
  // @@protoc_insertion_point(field_get:pb.DataMember.name)
  return *name_;
}
inline void DataMember::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.DataMember.name)
}
inline void DataMember::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.DataMember.name)
}
inline void DataMember::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.DataMember.name)
}
inline ::std::string* DataMember::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.DataMember.name)
  return name_;
}
inline ::std::string* DataMember::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataMember::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataMember.name)
}

// optional bool extend_to = 3;
inline bool DataMember::has_extend_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataMember::set_has_extend_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataMember::clear_has_extend_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataMember::clear_extend_to() {
  extend_to_ = false;
  clear_has_extend_to();
}
inline bool DataMember::extend_to() const {
  // @@protoc_insertion_point(field_get:pb.DataMember.extend_to)
  return extend_to_;
}
inline void DataMember::set_extend_to(bool value) {
  set_has_extend_to();
  extend_to_ = value;
  // @@protoc_insertion_point(field_set:pb.DataMember.extend_to)
}

// optional .pb.Variant default_value = 4;
inline bool DataMember::has_default_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataMember::set_has_default_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataMember::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataMember::clear_default_value() {
  if (default_value_ != NULL) default_value_->::pb::Variant::Clear();
  clear_has_default_value();
}
inline const ::pb::Variant& DataMember::default_value() const {
  // @@protoc_insertion_point(field_get:pb.DataMember.default_value)
  return default_value_ != NULL ? *default_value_ : *default_instance_->default_value_;
}
inline ::pb::Variant* DataMember::mutable_default_value() {
  set_has_default_value();
  if (default_value_ == NULL) default_value_ = new ::pb::Variant;
  // @@protoc_insertion_point(field_mutable:pb.DataMember.default_value)
  return default_value_;
}
inline ::pb::Variant* DataMember::release_default_value() {
  clear_has_default_value();
  ::pb::Variant* temp = default_value_;
  default_value_ = NULL;
  return temp;
}
inline void DataMember::set_allocated_default_value(::pb::Variant* default_value) {
  delete default_value_;
  default_value_ = default_value;
  if (default_value) {
    set_has_default_value();
  } else {
    clear_has_default_value();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataMember.default_value)
}

// repeated string when_discriminant = 5;
inline int DataMember::when_discriminant_size() const {
  return when_discriminant_.size();
}
inline void DataMember::clear_when_discriminant() {
  when_discriminant_.Clear();
}
inline const ::std::string& DataMember::when_discriminant(int index) const {
  // @@protoc_insertion_point(field_get:pb.DataMember.when_discriminant)
  return when_discriminant_.Get(index);
}
inline ::std::string* DataMember::mutable_when_discriminant(int index) {
  // @@protoc_insertion_point(field_mutable:pb.DataMember.when_discriminant)
  return when_discriminant_.Mutable(index);
}
inline void DataMember::set_when_discriminant(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.DataMember.when_discriminant)
  when_discriminant_.Mutable(index)->assign(value);
}
inline void DataMember::set_when_discriminant(int index, const char* value) {
  when_discriminant_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.DataMember.when_discriminant)
}
inline void DataMember::set_when_discriminant(int index, const char* value, size_t size) {
  when_discriminant_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.DataMember.when_discriminant)
}
inline ::std::string* DataMember::add_when_discriminant() {
  return when_discriminant_.Add();
}
inline void DataMember::add_when_discriminant(const ::std::string& value) {
  when_discriminant_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.DataMember.when_discriminant)
}
inline void DataMember::add_when_discriminant(const char* value) {
  when_discriminant_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.DataMember.when_discriminant)
}
inline void DataMember::add_when_discriminant(const char* value, size_t size) {
  when_discriminant_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.DataMember.when_discriminant)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataMember::when_discriminant() const {
  // @@protoc_insertion_point(field_list:pb.DataMember.when_discriminant)
  return when_discriminant_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataMember::mutable_when_discriminant() {
  // @@protoc_insertion_point(field_mutable_list:pb.DataMember.when_discriminant)
  return &when_discriminant_;
}

// optional .pb.EncodedOrMember __parent = 6;
inline bool DataMember::has___parent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataMember::set_has___parent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataMember::clear_has___parent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataMember::clear___parent() {
  if (__parent_ != NULL) __parent_->::pb::EncodedOrMember::Clear();
  clear_has___parent();
}
inline const ::pb::EncodedOrMember& DataMember::__parent() const {
  // @@protoc_insertion_point(field_get:pb.DataMember.__parent)
  return __parent_ != NULL ? *__parent_ : *default_instance_->__parent_;
}
inline ::pb::EncodedOrMember* DataMember::mutable___parent() {
  set_has___parent();
  if (__parent_ == NULL) __parent_ = new ::pb::EncodedOrMember;
  // @@protoc_insertion_point(field_mutable:pb.DataMember.__parent)
  return __parent_;
}
inline ::pb::EncodedOrMember* DataMember::release___parent() {
  clear_has___parent();
  ::pb::EncodedOrMember* temp = __parent_;
  __parent_ = NULL;
  return temp;
}
inline void DataMember::set_allocated___parent(::pb::EncodedOrMember* __parent) {
  delete __parent_;
  __parent_ = __parent;
  if (__parent) {
    set_has___parent();
  } else {
    clear_has___parent();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.DataMember.__parent)
}

// -------------------------------------------------------------------

// EncodedMembers

// optional .pb.EncodingSpecifics encoding_specifics = 1;
inline bool EncodedMembers::has_encoding_specifics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncodedMembers::set_has_encoding_specifics() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncodedMembers::clear_has_encoding_specifics() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncodedMembers::clear_encoding_specifics() {
  if (encoding_specifics_ != NULL) encoding_specifics_->::pb::EncodingSpecifics::Clear();
  clear_has_encoding_specifics();
}
inline const ::pb::EncodingSpecifics& EncodedMembers::encoding_specifics() const {
  // @@protoc_insertion_point(field_get:pb.EncodedMembers.encoding_specifics)
  return encoding_specifics_ != NULL ? *encoding_specifics_ : *default_instance_->encoding_specifics_;
}
inline ::pb::EncodingSpecifics* EncodedMembers::mutable_encoding_specifics() {
  set_has_encoding_specifics();
  if (encoding_specifics_ == NULL) encoding_specifics_ = new ::pb::EncodingSpecifics;
  // @@protoc_insertion_point(field_mutable:pb.EncodedMembers.encoding_specifics)
  return encoding_specifics_;
}
inline ::pb::EncodingSpecifics* EncodedMembers::release_encoding_specifics() {
  clear_has_encoding_specifics();
  ::pb::EncodingSpecifics* temp = encoding_specifics_;
  encoding_specifics_ = NULL;
  return temp;
}
inline void EncodedMembers::set_allocated_encoding_specifics(::pb::EncodingSpecifics* encoding_specifics) {
  delete encoding_specifics_;
  encoding_specifics_ = encoding_specifics;
  if (encoding_specifics) {
    set_has_encoding_specifics();
  } else {
    clear_has_encoding_specifics();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EncodedMembers.encoding_specifics)
}

// repeated .pb.__unique_ptr_EncodedOrMember members = 2;
inline int EncodedMembers::members_size() const {
  return members_.size();
}
inline void EncodedMembers::clear_members() {
  members_.Clear();
}
inline const ::pb::__unique_ptr_EncodedOrMember& EncodedMembers::members(int index) const {
  // @@protoc_insertion_point(field_get:pb.EncodedMembers.members)
  return members_.Get(index);
}
inline ::pb::__unique_ptr_EncodedOrMember* EncodedMembers::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EncodedMembers.members)
  return members_.Mutable(index);
}
inline ::pb::__unique_ptr_EncodedOrMember* EncodedMembers::add_members() {
  // @@protoc_insertion_point(field_add:pb.EncodedMembers.members)
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_EncodedOrMember >&
EncodedMembers::members() const {
  // @@protoc_insertion_point(field_list:pb.EncodedMembers.members)
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_EncodedOrMember >*
EncodedMembers::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:pb.EncodedMembers.members)
  return &members_;
}

// optional .pb.EncodedOrMember __parent = 3;
inline bool EncodedMembers::has___parent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncodedMembers::set_has___parent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncodedMembers::clear_has___parent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncodedMembers::clear___parent() {
  if (__parent_ != NULL) __parent_->::pb::EncodedOrMember::Clear();
  clear_has___parent();
}
inline const ::pb::EncodedOrMember& EncodedMembers::__parent() const {
  // @@protoc_insertion_point(field_get:pb.EncodedMembers.__parent)
  return __parent_ != NULL ? *__parent_ : *default_instance_->__parent_;
}
inline ::pb::EncodedOrMember* EncodedMembers::mutable___parent() {
  set_has___parent();
  if (__parent_ == NULL) __parent_ = new ::pb::EncodedOrMember;
  // @@protoc_insertion_point(field_mutable:pb.EncodedMembers.__parent)
  return __parent_;
}
inline ::pb::EncodedOrMember* EncodedMembers::release___parent() {
  clear_has___parent();
  ::pb::EncodedOrMember* temp = __parent_;
  __parent_ = NULL;
  return temp;
}
inline void EncodedMembers::set_allocated___parent(::pb::EncodedOrMember* __parent) {
  delete __parent_;
  __parent_ = __parent;
  if (__parent) {
    set_has___parent();
  } else {
    clear_has___parent();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EncodedMembers.__parent)
}

// -------------------------------------------------------------------

// Structure

// optional .pb.Structure.DECLTYPE decl_type = 1;
inline bool Structure::has_decl_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Structure::set_has_decl_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Structure::clear_has_decl_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Structure::clear_decl_type() {
  decl_type_ = 0;
  clear_has_decl_type();
}
inline ::pb::Structure_DECLTYPE Structure::decl_type() const {
  // @@protoc_insertion_point(field_get:pb.Structure.decl_type)
  return static_cast< ::pb::Structure_DECLTYPE >(decl_type_);
}
inline void Structure::set_decl_type(::pb::Structure_DECLTYPE value) {
  assert(::pb::Structure_DECLTYPE_IsValid(value));
  set_has_decl_type();
  decl_type_ = value;
  // @@protoc_insertion_point(field_set:pb.Structure.decl_type)
}

// optional .pb.Structure.TYPE type = 2;
inline bool Structure::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Structure::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Structure::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Structure::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pb::Structure_TYPE Structure::type() const {
  // @@protoc_insertion_point(field_get:pb.Structure.type)
  return static_cast< ::pb::Structure_TYPE >(type_);
}
inline void Structure::set_type(::pb::Structure_TYPE value) {
  assert(::pb::Structure_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.Structure.type)
}

// optional string name = 3;
inline bool Structure::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Structure::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Structure::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Structure::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Structure::name() const {
  // @@protoc_insertion_point(field_get:pb.Structure.name)
  return *name_;
}
inline void Structure::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Structure.name)
}
inline void Structure::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Structure.name)
}
inline void Structure::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Structure.name)
}
inline ::std::string* Structure::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Structure.name)
  return name_;
}
inline ::std::string* Structure::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Structure::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Structure.name)
}

// optional string discriminant = 4;
inline bool Structure::has_discriminant() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Structure::set_has_discriminant() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Structure::clear_has_discriminant() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Structure::clear_discriminant() {
  if (discriminant_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discriminant_->clear();
  }
  clear_has_discriminant();
}
inline const ::std::string& Structure::discriminant() const {
  // @@protoc_insertion_point(field_get:pb.Structure.discriminant)
  return *discriminant_;
}
inline void Structure::set_discriminant(const ::std::string& value) {
  set_has_discriminant();
  if (discriminant_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discriminant_ = new ::std::string;
  }
  discriminant_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Structure.discriminant)
}
inline void Structure::set_discriminant(const char* value) {
  set_has_discriminant();
  if (discriminant_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discriminant_ = new ::std::string;
  }
  discriminant_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Structure.discriminant)
}
inline void Structure::set_discriminant(const char* value, size_t size) {
  set_has_discriminant();
  if (discriminant_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discriminant_ = new ::std::string;
  }
  discriminant_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Structure.discriminant)
}
inline ::std::string* Structure::mutable_discriminant() {
  set_has_discriminant();
  if (discriminant_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    discriminant_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Structure.discriminant)
  return discriminant_;
}
inline ::std::string* Structure::release_discriminant() {
  clear_has_discriminant();
  if (discriminant_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = discriminant_;
    discriminant_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Structure::set_allocated_discriminant(::std::string* discriminant) {
  if (discriminant_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete discriminant_;
  }
  if (discriminant) {
    set_has_discriminant();
    discriminant_ = discriminant;
  } else {
    clear_has_discriminant();
    discriminant_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Structure.discriminant)
}

// optional string inherited_from = 5;
inline bool Structure::has_inherited_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Structure::set_has_inherited_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Structure::clear_has_inherited_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Structure::clear_inherited_from() {
  if (inherited_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inherited_from_->clear();
  }
  clear_has_inherited_from();
}
inline const ::std::string& Structure::inherited_from() const {
  // @@protoc_insertion_point(field_get:pb.Structure.inherited_from)
  return *inherited_from_;
}
inline void Structure::set_inherited_from(const ::std::string& value) {
  set_has_inherited_from();
  if (inherited_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inherited_from_ = new ::std::string;
  }
  inherited_from_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Structure.inherited_from)
}
inline void Structure::set_inherited_from(const char* value) {
  set_has_inherited_from();
  if (inherited_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inherited_from_ = new ::std::string;
  }
  inherited_from_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Structure.inherited_from)
}
inline void Structure::set_inherited_from(const char* value, size_t size) {
  set_has_inherited_from();
  if (inherited_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inherited_from_ = new ::std::string;
  }
  inherited_from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Structure.inherited_from)
}
inline ::std::string* Structure::mutable_inherited_from() {
  set_has_inherited_from();
  if (inherited_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inherited_from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Structure.inherited_from)
  return inherited_from_;
}
inline ::std::string* Structure::release_inherited_from() {
  clear_has_inherited_from();
  if (inherited_from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inherited_from_;
    inherited_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Structure::set_allocated_inherited_from(::std::string* inherited_from) {
  if (inherited_from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inherited_from_;
  }
  if (inherited_from) {
    set_has_inherited_from();
    inherited_from_ = inherited_from;
  } else {
    clear_has_inherited_from();
    inherited_from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Structure.inherited_from)
}

// optional .pb.EncodedMembers __parent = 6;
inline bool Structure::has___parent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Structure::set_has___parent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Structure::clear_has___parent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Structure::clear___parent() {
  if (__parent_ != NULL) __parent_->::pb::EncodedMembers::Clear();
  clear_has___parent();
}
inline const ::pb::EncodedMembers& Structure::__parent() const {
  // @@protoc_insertion_point(field_get:pb.Structure.__parent)
  return __parent_ != NULL ? *__parent_ : *default_instance_->__parent_;
}
inline ::pb::EncodedMembers* Structure::mutable___parent() {
  set_has___parent();
  if (__parent_ == NULL) __parent_ = new ::pb::EncodedMembers;
  // @@protoc_insertion_point(field_mutable:pb.Structure.__parent)
  return __parent_;
}
inline ::pb::EncodedMembers* Structure::release___parent() {
  clear_has___parent();
  ::pb::EncodedMembers* temp = __parent_;
  __parent_ = NULL;
  return temp;
}
inline void Structure::set_allocated___parent(::pb::EncodedMembers* __parent) {
  delete __parent_;
  __parent_ = __parent;
  if (__parent) {
    set_has___parent();
  } else {
    clear_has___parent();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Structure.__parent)
}

// -------------------------------------------------------------------

// Typedef

// optional .pb.Location location = 1;
inline bool Typedef::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Typedef::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Typedef::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Typedef::clear_location() {
  if (location_ != NULL) location_->::pb::Location::Clear();
  clear_has_location();
}
inline const ::pb::Location& Typedef::location() const {
  // @@protoc_insertion_point(field_get:pb.Typedef.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::pb::Location* Typedef::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::pb::Location;
  // @@protoc_insertion_point(field_mutable:pb.Typedef.location)
  return location_;
}
inline ::pb::Location* Typedef::release_location() {
  clear_has_location();
  ::pb::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Typedef::set_allocated_location(::pb::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Typedef.location)
}

// optional .pb.DataType type = 2;
inline bool Typedef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Typedef::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Typedef::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Typedef::clear_type() {
  if (type_ != NULL) type_->::pb::DataType::Clear();
  clear_has_type();
}
inline const ::pb::DataType& Typedef::type() const {
  // @@protoc_insertion_point(field_get:pb.Typedef.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::pb::DataType* Typedef::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::pb::DataType;
  // @@protoc_insertion_point(field_mutable:pb.Typedef.type)
  return type_;
}
inline ::pb::DataType* Typedef::release_type() {
  clear_has_type();
  ::pb::DataType* temp = type_;
  type_ = NULL;
  return temp;
}
inline void Typedef::set_allocated_type(::pb::DataType* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Typedef.type)
}

// optional string name = 3;
inline bool Typedef::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Typedef::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Typedef::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Typedef::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Typedef::name() const {
  // @@protoc_insertion_point(field_get:pb.Typedef.name)
  return *name_;
}
inline void Typedef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Typedef.name)
}
inline void Typedef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Typedef.name)
}
inline void Typedef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Typedef.name)
}
inline ::std::string* Typedef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Typedef.name)
  return name_;
}
inline ::std::string* Typedef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Typedef::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Typedef.name)
}

// -------------------------------------------------------------------

// Root

// repeated .pb.Typedef typedefs = 1;
inline int Root::typedefs_size() const {
  return typedefs_.size();
}
inline void Root::clear_typedefs() {
  typedefs_.Clear();
}
inline const ::pb::Typedef& Root::typedefs(int index) const {
  // @@protoc_insertion_point(field_get:pb.Root.typedefs)
  return typedefs_.Get(index);
}
inline ::pb::Typedef* Root::mutable_typedefs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Root.typedefs)
  return typedefs_.Mutable(index);
}
inline ::pb::Typedef* Root::add_typedefs() {
  // @@protoc_insertion_point(field_add:pb.Root.typedefs)
  return typedefs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Typedef >&
Root::typedefs() const {
  // @@protoc_insertion_point(field_list:pb.Root.typedefs)
  return typedefs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Typedef >*
Root::mutable_typedefs() {
  // @@protoc_insertion_point(field_mutable_list:pb.Root.typedefs)
  return &typedefs_;
}

// repeated .pb.__unique_ptr_Structure structures = 2;
inline int Root::structures_size() const {
  return structures_.size();
}
inline void Root::clear_structures() {
  structures_.Clear();
}
inline const ::pb::__unique_ptr_Structure& Root::structures(int index) const {
  // @@protoc_insertion_point(field_get:pb.Root.structures)
  return structures_.Get(index);
}
inline ::pb::__unique_ptr_Structure* Root::mutable_structures(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Root.structures)
  return structures_.Mutable(index);
}
inline ::pb::__unique_ptr_Structure* Root::add_structures() {
  // @@protoc_insertion_point(field_add:pb.Root.structures)
  return structures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_Structure >&
Root::structures() const {
  // @@protoc_insertion_point(field_list:pb.Root.structures)
  return structures_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::__unique_ptr_Structure >*
Root::mutable_structures() {
  // @@protoc_insertion_point(field_mutable_list:pb.Root.structures)
  return &structures_;
}

// repeated sint32 packed_var_ints = 3 [packed = true];
inline int Root::packed_var_ints_size() const {
  return packed_var_ints_.size();
}
inline void Root::clear_packed_var_ints() {
  packed_var_ints_.Clear();
}
inline ::google::protobuf::int32 Root::packed_var_ints(int index) const {
  // @@protoc_insertion_point(field_get:pb.Root.packed_var_ints)
  return packed_var_ints_.Get(index);
}
inline void Root::set_packed_var_ints(int index, ::google::protobuf::int32 value) {
  packed_var_ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.Root.packed_var_ints)
}
inline void Root::add_packed_var_ints(::google::protobuf::int32 value) {
  packed_var_ints_.Add(value);
  // @@protoc_insertion_point(field_add:pb.Root.packed_var_ints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Root::packed_var_ints() const {
  // @@protoc_insertion_point(field_list:pb.Root.packed_var_ints)
  return packed_var_ints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Root::mutable_packed_var_ints() {
  // @@protoc_insertion_point(field_mutable_list:pb.Root.packed_var_ints)
  return &packed_var_ints_;
}

// repeated double packed_doubles = 4 [packed = true];
inline int Root::packed_doubles_size() const {
  return packed_doubles_.size();
}
inline void Root::clear_packed_doubles() {
  packed_doubles_.Clear();
}
inline double Root::packed_doubles(int index) const {
  // @@protoc_insertion_point(field_get:pb.Root.packed_doubles)
  return packed_doubles_.Get(index);
}
inline void Root::set_packed_doubles(int index, double value) {
  packed_doubles_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.Root.packed_doubles)
}
inline void Root::add_packed_doubles(double value) {
  packed_doubles_.Add(value);
  // @@protoc_insertion_point(field_add:pb.Root.packed_doubles)
}
inline const ::google::protobuf::RepeatedField< double >&
Root::packed_doubles() const {
  // @@protoc_insertion_point(field_list:pb.Root.packed_doubles)
  return packed_doubles_;
}
inline ::google::protobuf::RepeatedField< double >*
Root::mutable_packed_doubles() {
  // @@protoc_insertion_point(field_mutable_list:pb.Root.packed_doubles)
  return &packed_doubles_;
}

// repeated string unpacked_strings = 5;
inline int Root::unpacked_strings_size() const {
  return unpacked_strings_.size();
}
inline void Root::clear_unpacked_strings() {
  unpacked_strings_.Clear();
}
inline const ::std::string& Root::unpacked_strings(int index) const {
  // @@protoc_insertion_point(field_get:pb.Root.unpacked_strings)
  return unpacked_strings_.Get(index);
}
inline ::std::string* Root::mutable_unpacked_strings(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Root.unpacked_strings)
  return unpacked_strings_.Mutable(index);
}
inline void Root::set_unpacked_strings(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Root.unpacked_strings)
  unpacked_strings_.Mutable(index)->assign(value);
}
inline void Root::set_unpacked_strings(int index, const char* value) {
  unpacked_strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Root.unpacked_strings)
}
inline void Root::set_unpacked_strings(int index, const char* value, size_t size) {
  unpacked_strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Root.unpacked_strings)
}
inline ::std::string* Root::add_unpacked_strings() {
  return unpacked_strings_.Add();
}
inline void Root::add_unpacked_strings(const ::std::string& value) {
  unpacked_strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Root.unpacked_strings)
}
inline void Root::add_unpacked_strings(const char* value) {
  unpacked_strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Root.unpacked_strings)
}
inline void Root::add_unpacked_strings(const char* value, size_t size) {
  unpacked_strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Root.unpacked_strings)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Root::unpacked_strings() const {
  // @@protoc_insertion_point(field_list:pb.Root.unpacked_strings)
  return unpacked_strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Root::mutable_unpacked_strings() {
  // @@protoc_insertion_point(field_mutable_list:pb.Root.unpacked_strings)
  return &unpacked_strings_;
}

// -------------------------------------------------------------------

// __unique_ptr_DataType

// optional .pb.__unique_ptr_DataType.Discriminator discriminator = 1;
inline bool __unique_ptr_DataType::has_discriminator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void __unique_ptr_DataType::set_has_discriminator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void __unique_ptr_DataType::clear_has_discriminator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void __unique_ptr_DataType::clear_discriminator() {
  discriminator_ = 0;
  clear_has_discriminator();
}
inline ::pb::__unique_ptr_DataType_Discriminator __unique_ptr_DataType::discriminator() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_DataType.discriminator)
  return static_cast< ::pb::__unique_ptr_DataType_Discriminator >(discriminator_);
}
inline void __unique_ptr_DataType::set_discriminator(::pb::__unique_ptr_DataType_Discriminator value) {
  assert(::pb::__unique_ptr_DataType_Discriminator_IsValid(value));
  set_has_discriminator();
  discriminator_ = value;
  // @@protoc_insertion_point(field_set:pb.__unique_ptr_DataType.discriminator)
}

// optional .pb.DataType du_data_type = 2;
inline bool __unique_ptr_DataType::has_du_data_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void __unique_ptr_DataType::set_has_du_data_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void __unique_ptr_DataType::clear_has_du_data_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void __unique_ptr_DataType::clear_du_data_type() {
  if (du_data_type_ != NULL) du_data_type_->::pb::DataType::Clear();
  clear_has_du_data_type();
}
inline const ::pb::DataType& __unique_ptr_DataType::du_data_type() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_DataType.du_data_type)
  return du_data_type_ != NULL ? *du_data_type_ : *default_instance_->du_data_type_;
}
inline ::pb::DataType* __unique_ptr_DataType::mutable_du_data_type() {
  set_has_du_data_type();
  if (du_data_type_ == NULL) du_data_type_ = new ::pb::DataType;
  // @@protoc_insertion_point(field_mutable:pb.__unique_ptr_DataType.du_data_type)
  return du_data_type_;
}
inline ::pb::DataType* __unique_ptr_DataType::release_du_data_type() {
  clear_has_du_data_type();
  ::pb::DataType* temp = du_data_type_;
  du_data_type_ = NULL;
  return temp;
}
inline void __unique_ptr_DataType::set_allocated_du_data_type(::pb::DataType* du_data_type) {
  delete du_data_type_;
  du_data_type_ = du_data_type;
  if (du_data_type) {
    set_has_du_data_type();
  } else {
    clear_has_du_data_type();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.__unique_ptr_DataType.du_data_type)
}

// -------------------------------------------------------------------

// __unique_ptr_EncodedOrMember

// optional .pb.__unique_ptr_EncodedOrMember.Discriminator discriminator = 1;
inline bool __unique_ptr_EncodedOrMember::has_discriminator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void __unique_ptr_EncodedOrMember::set_has_discriminator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void __unique_ptr_EncodedOrMember::clear_has_discriminator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void __unique_ptr_EncodedOrMember::clear_discriminator() {
  discriminator_ = 0;
  clear_has_discriminator();
}
inline ::pb::__unique_ptr_EncodedOrMember_Discriminator __unique_ptr_EncodedOrMember::discriminator() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_EncodedOrMember.discriminator)
  return static_cast< ::pb::__unique_ptr_EncodedOrMember_Discriminator >(discriminator_);
}
inline void __unique_ptr_EncodedOrMember::set_discriminator(::pb::__unique_ptr_EncodedOrMember_Discriminator value) {
  assert(::pb::__unique_ptr_EncodedOrMember_Discriminator_IsValid(value));
  set_has_discriminator();
  discriminator_ = value;
  // @@protoc_insertion_point(field_set:pb.__unique_ptr_EncodedOrMember.discriminator)
}

// optional .pb.DataMember du_data_member = 2;
inline bool __unique_ptr_EncodedOrMember::has_du_data_member() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void __unique_ptr_EncodedOrMember::set_has_du_data_member() {
  _has_bits_[0] |= 0x00000002u;
}
inline void __unique_ptr_EncodedOrMember::clear_has_du_data_member() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void __unique_ptr_EncodedOrMember::clear_du_data_member() {
  if (du_data_member_ != NULL) du_data_member_->::pb::DataMember::Clear();
  clear_has_du_data_member();
}
inline const ::pb::DataMember& __unique_ptr_EncodedOrMember::du_data_member() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_EncodedOrMember.du_data_member)
  return du_data_member_ != NULL ? *du_data_member_ : *default_instance_->du_data_member_;
}
inline ::pb::DataMember* __unique_ptr_EncodedOrMember::mutable_du_data_member() {
  set_has_du_data_member();
  if (du_data_member_ == NULL) du_data_member_ = new ::pb::DataMember;
  // @@protoc_insertion_point(field_mutable:pb.__unique_ptr_EncodedOrMember.du_data_member)
  return du_data_member_;
}
inline ::pb::DataMember* __unique_ptr_EncodedOrMember::release_du_data_member() {
  clear_has_du_data_member();
  ::pb::DataMember* temp = du_data_member_;
  du_data_member_ = NULL;
  return temp;
}
inline void __unique_ptr_EncodedOrMember::set_allocated_du_data_member(::pb::DataMember* du_data_member) {
  delete du_data_member_;
  du_data_member_ = du_data_member;
  if (du_data_member) {
    set_has_du_data_member();
  } else {
    clear_has_du_data_member();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.__unique_ptr_EncodedOrMember.du_data_member)
}

// optional .pb.EncodedMembers du_encoded_members = 3;
inline bool __unique_ptr_EncodedOrMember::has_du_encoded_members() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void __unique_ptr_EncodedOrMember::set_has_du_encoded_members() {
  _has_bits_[0] |= 0x00000004u;
}
inline void __unique_ptr_EncodedOrMember::clear_has_du_encoded_members() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void __unique_ptr_EncodedOrMember::clear_du_encoded_members() {
  if (du_encoded_members_ != NULL) du_encoded_members_->::pb::EncodedMembers::Clear();
  clear_has_du_encoded_members();
}
inline const ::pb::EncodedMembers& __unique_ptr_EncodedOrMember::du_encoded_members() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_EncodedOrMember.du_encoded_members)
  return du_encoded_members_ != NULL ? *du_encoded_members_ : *default_instance_->du_encoded_members_;
}
inline ::pb::EncodedMembers* __unique_ptr_EncodedOrMember::mutable_du_encoded_members() {
  set_has_du_encoded_members();
  if (du_encoded_members_ == NULL) du_encoded_members_ = new ::pb::EncodedMembers;
  // @@protoc_insertion_point(field_mutable:pb.__unique_ptr_EncodedOrMember.du_encoded_members)
  return du_encoded_members_;
}
inline ::pb::EncodedMembers* __unique_ptr_EncodedOrMember::release_du_encoded_members() {
  clear_has_du_encoded_members();
  ::pb::EncodedMembers* temp = du_encoded_members_;
  du_encoded_members_ = NULL;
  return temp;
}
inline void __unique_ptr_EncodedOrMember::set_allocated_du_encoded_members(::pb::EncodedMembers* du_encoded_members) {
  delete du_encoded_members_;
  du_encoded_members_ = du_encoded_members;
  if (du_encoded_members) {
    set_has_du_encoded_members();
  } else {
    clear_has_du_encoded_members();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.__unique_ptr_EncodedOrMember.du_encoded_members)
}

// optional .pb.EncodedOrMember du_encoded_or_member = 4;
inline bool __unique_ptr_EncodedOrMember::has_du_encoded_or_member() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void __unique_ptr_EncodedOrMember::set_has_du_encoded_or_member() {
  _has_bits_[0] |= 0x00000008u;
}
inline void __unique_ptr_EncodedOrMember::clear_has_du_encoded_or_member() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void __unique_ptr_EncodedOrMember::clear_du_encoded_or_member() {
  if (du_encoded_or_member_ != NULL) du_encoded_or_member_->::pb::EncodedOrMember::Clear();
  clear_has_du_encoded_or_member();
}
inline const ::pb::EncodedOrMember& __unique_ptr_EncodedOrMember::du_encoded_or_member() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_EncodedOrMember.du_encoded_or_member)
  return du_encoded_or_member_ != NULL ? *du_encoded_or_member_ : *default_instance_->du_encoded_or_member_;
}
inline ::pb::EncodedOrMember* __unique_ptr_EncodedOrMember::mutable_du_encoded_or_member() {
  set_has_du_encoded_or_member();
  if (du_encoded_or_member_ == NULL) du_encoded_or_member_ = new ::pb::EncodedOrMember;
  // @@protoc_insertion_point(field_mutable:pb.__unique_ptr_EncodedOrMember.du_encoded_or_member)
  return du_encoded_or_member_;
}
inline ::pb::EncodedOrMember* __unique_ptr_EncodedOrMember::release_du_encoded_or_member() {
  clear_has_du_encoded_or_member();
  ::pb::EncodedOrMember* temp = du_encoded_or_member_;
  du_encoded_or_member_ = NULL;
  return temp;
}
inline void __unique_ptr_EncodedOrMember::set_allocated_du_encoded_or_member(::pb::EncodedOrMember* du_encoded_or_member) {
  delete du_encoded_or_member_;
  du_encoded_or_member_ = du_encoded_or_member;
  if (du_encoded_or_member) {
    set_has_du_encoded_or_member();
  } else {
    clear_has_du_encoded_or_member();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.__unique_ptr_EncodedOrMember.du_encoded_or_member)
}

// -------------------------------------------------------------------

// __unique_ptr_Structure

// optional .pb.__unique_ptr_Structure.Discriminator discriminator = 1;
inline bool __unique_ptr_Structure::has_discriminator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void __unique_ptr_Structure::set_has_discriminator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void __unique_ptr_Structure::clear_has_discriminator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void __unique_ptr_Structure::clear_discriminator() {
  discriminator_ = 0;
  clear_has_discriminator();
}
inline ::pb::__unique_ptr_Structure_Discriminator __unique_ptr_Structure::discriminator() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_Structure.discriminator)
  return static_cast< ::pb::__unique_ptr_Structure_Discriminator >(discriminator_);
}
inline void __unique_ptr_Structure::set_discriminator(::pb::__unique_ptr_Structure_Discriminator value) {
  assert(::pb::__unique_ptr_Structure_Discriminator_IsValid(value));
  set_has_discriminator();
  discriminator_ = value;
  // @@protoc_insertion_point(field_set:pb.__unique_ptr_Structure.discriminator)
}

// optional .pb.Structure du_structure = 2;
inline bool __unique_ptr_Structure::has_du_structure() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void __unique_ptr_Structure::set_has_du_structure() {
  _has_bits_[0] |= 0x00000002u;
}
inline void __unique_ptr_Structure::clear_has_du_structure() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void __unique_ptr_Structure::clear_du_structure() {
  if (du_structure_ != NULL) du_structure_->::pb::Structure::Clear();
  clear_has_du_structure();
}
inline const ::pb::Structure& __unique_ptr_Structure::du_structure() const {
  // @@protoc_insertion_point(field_get:pb.__unique_ptr_Structure.du_structure)
  return du_structure_ != NULL ? *du_structure_ : *default_instance_->du_structure_;
}
inline ::pb::Structure* __unique_ptr_Structure::mutable_du_structure() {
  set_has_du_structure();
  if (du_structure_ == NULL) du_structure_ = new ::pb::Structure;
  // @@protoc_insertion_point(field_mutable:pb.__unique_ptr_Structure.du_structure)
  return du_structure_;
}
inline ::pb::Structure* __unique_ptr_Structure::release_du_structure() {
  clear_has_du_structure();
  ::pb::Structure* temp = du_structure_;
  du_structure_ = NULL;
  return temp;
}
inline void __unique_ptr_Structure::set_allocated_du_structure(::pb::Structure* du_structure) {
  delete du_structure_;
  du_structure_ = du_structure;
  if (du_structure) {
    set_has_du_structure();
  } else {
    clear_has_du_structure();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.__unique_ptr_Structure.du_structure)
}

// -------------------------------------------------------------------

// map_string_Variant

// optional string key = 1;
inline bool map_string_Variant::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void map_string_Variant::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void map_string_Variant::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void map_string_Variant::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& map_string_Variant::key() const {
  // @@protoc_insertion_point(field_get:pb.map_string_Variant.key)
  return *key_;
}
inline void map_string_Variant::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:pb.map_string_Variant.key)
}
inline void map_string_Variant::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.map_string_Variant.key)
}
inline void map_string_Variant::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.map_string_Variant.key)
}
inline ::std::string* map_string_Variant::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.map_string_Variant.key)
  return key_;
}
inline ::std::string* map_string_Variant::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void map_string_Variant::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.map_string_Variant.key)
}

// optional .pb.Variant value = 2;
inline bool map_string_Variant::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void map_string_Variant::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void map_string_Variant::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void map_string_Variant::clear_value() {
  if (value_ != NULL) value_->::pb::Variant::Clear();
  clear_has_value();
}
inline const ::pb::Variant& map_string_Variant::value() const {
  // @@protoc_insertion_point(field_get:pb.map_string_Variant.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::pb::Variant* map_string_Variant::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::pb::Variant;
  // @@protoc_insertion_point(field_mutable:pb.map_string_Variant.value)
  return value_;
}
inline ::pb::Variant* map_string_Variant::release_value() {
  clear_has_value();
  ::pb::Variant* temp = value_;
  value_ = NULL;
  return temp;
}
inline void map_string_Variant::set_allocated_value(::pb::Variant* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.map_string_Variant.value)
}

// -------------------------------------------------------------------

// map_string_uint32

// optional string key = 1;
inline bool map_string_uint32::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void map_string_uint32::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void map_string_uint32::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void map_string_uint32::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& map_string_uint32::key() const {
  // @@protoc_insertion_point(field_get:pb.map_string_uint32.key)
  return *key_;
}
inline void map_string_uint32::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:pb.map_string_uint32.key)
}
inline void map_string_uint32::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.map_string_uint32.key)
}
inline void map_string_uint32::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.map_string_uint32.key)
}
inline ::std::string* map_string_uint32::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.map_string_uint32.key)
  return key_;
}
inline ::std::string* map_string_uint32::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void map_string_uint32::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.map_string_uint32.key)
}

// optional uint32 value = 2;
inline bool map_string_uint32::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void map_string_uint32::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void map_string_uint32::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void map_string_uint32::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 map_string_uint32::value() const {
  // @@protoc_insertion_point(field_get:pb.map_string_uint32.value)
  return value_;
}
inline void map_string_uint32::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.map_string_uint32.value)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::Variant_KIND> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Variant_KIND>() {
  return ::pb::Variant_KIND_descriptor();
}
template <> struct is_proto_enum< ::pb::DataType_KIND> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::DataType_KIND>() {
  return ::pb::DataType_KIND_descriptor();
}
template <> struct is_proto_enum< ::pb::Structure_DECLTYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Structure_DECLTYPE>() {
  return ::pb::Structure_DECLTYPE_descriptor();
}
template <> struct is_proto_enum< ::pb::Structure_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Structure_TYPE>() {
  return ::pb::Structure_TYPE_descriptor();
}
template <> struct is_proto_enum< ::pb::__unique_ptr_DataType_Discriminator> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::__unique_ptr_DataType_Discriminator>() {
  return ::pb::__unique_ptr_DataType_Discriminator_descriptor();
}
template <> struct is_proto_enum< ::pb::__unique_ptr_EncodedOrMember_Discriminator> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::__unique_ptr_EncodedOrMember_Discriminator>() {
  return ::pb::__unique_ptr_EncodedOrMember_Discriminator_descriptor();
}
template <> struct is_proto_enum< ::pb::__unique_ptr_Structure_Discriminator> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::__unique_ptr_Structure_Discriminator>() {
  return ::pb::__unique_ptr_Structure_Discriminator_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_output_2eproto__INCLUDED
