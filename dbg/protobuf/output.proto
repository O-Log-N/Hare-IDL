
package pb;
//syntax="proto2"

// PROTO MESSAGES
message Limit {
  optional bool inclusive = 1;
  optional double value = 2;
}
message Location {
  optional string file_name = 1;
  optional sint32 line_number = 2;
}
message CharacterRange {
  optional uint32 from = 1;
  optional uint32 to = 2;
}
message CharacterSet {
  repeated CharacterRange ranges = 1;
}
message Variant {
  enum KIND {
    NONE = 0;
    NUMBER = 1;
    STRING = 2;
  }
  optional KIND  kind = 1;
  optional double number_value = 2;
  optional string string_value = 3;
}
message DataType {
  enum KIND {
    BIT_STRING = 0;
    CHARACTER = 1;
    CHARACTER_STRING = 2;
    DICTIONARY = 3;
    DISCRIMINATED_UNION = 4;
    ENCODING_SPECIFIC = 5;
    ENUM = 6;
    FIXED_POINT = 7;
    FLOATING_POINT = 8;
    INTEGER = 9;
    MAPPING_SPECIFIC = 10;
    NAMED_TYPE = 11;
    SEQUENCE = 12;
  }
  optional KIND  kind = 1;
  optional string name = 2;
  optional string mapping_name = 3;
  optional string encoding_name = 4;
  optional __unique_ptr_DataType  key_type = 5;
  optional __unique_ptr_DataType  param_type = 6;
  optional Limit  low_limit = 7;
  optional Limit  high_limit = 8;
  optional double fixed_precision = 9;
  optional uint32 floating_significand_bits = 10;
  optional uint32 floating_exponent_bits = 11;
  optional CharacterSet  character_set = 12;
  optional uint32 string_min_size = 13;
  optional uint32 string_max_size = 14;
  //  map< string , Variant > encoding_attrs = 15;
  repeated map_string_Variant encoding_attrs = 15;
  //  map< string , Variant > mapping_attrs = 16;
  repeated map_string_Variant mapping_attrs = 16;
  //  map< string , uint32 > enum_values = 17;
  repeated map_string_uint32 enum_values = 17;
}
message EncodingSpecifics {
  optional string name = 1;
  //  map< string , Variant > attrs = 2;
  repeated map_string_Variant attrs = 2;
}
message EncodedOrMember {
  optional Location  location = 1;
}
message DataMember {
  optional DataType  type = 1;
  optional string name = 2;
  optional bool extend_to = 3;
  optional Variant  default_value = 4;
  repeated string when_discriminant = 5;
  optional EncodedOrMember  __parent = 6;
}
message EncodedMembers {
  optional EncodingSpecifics  encoding_specifics = 1;
  repeated __unique_ptr_EncodedOrMember members = 2;
  optional EncodedOrMember  __parent = 3;
}
message Structure {
  enum DECLTYPE {
    ENCODING = 0;
    IDL = 1;
    MAPPING = 2;
  }
  optional DECLTYPE  decl_type = 1;
  enum TYPE {
    DISCRIMINATED_UNION = 0;
    RPC = 1;
    STRUCT = 2;
  }
  optional TYPE  type = 2;
  optional string name = 3;
  optional string discriminant = 4;
  optional string inherited_from = 5;
  optional EncodedMembers  __parent = 6;
}
message Typedef {
  optional Location  location = 1;
  optional DataType  type = 2;
  optional string name = 3;
}
message Root {
  repeated Typedef typedefs = 1;
  repeated __unique_ptr_Structure structures = 2;
  repeated sint32 packed_var_ints = 3 [packed=true];
  repeated double packed_doubles = 4 [packed=true];
  repeated string unpacked_strings = 5;
}
message __unique_ptr_DataType {
  enum Discriminator {
     OPT_DataType = 0;
     OPT_nullptr = 1;
  }
  optional Discriminator discriminator = 1;
  optional DataType  du_data_type = 2;
}
message __unique_ptr_EncodedOrMember {
  enum Discriminator {
     OPT_DataMember = 0;
     OPT_EncodedMembers = 1;
     OPT_EncodedOrMember = 2;
     OPT_nullptr = 3;
  }
  optional Discriminator discriminator = 1;
  optional DataMember  du_data_member = 2;
  optional EncodedMembers  du_encoded_members = 3;
  optional EncodedOrMember  du_encoded_or_member = 4;
}
message __unique_ptr_Structure {
  enum Discriminator {
     OPT_Structure = 0;
     OPT_nullptr = 1;
  }
  optional Discriminator discriminator = 1;
  optional Structure  du_structure = 2;
}
message map_string_Variant {
  optional string key = 1;
  optional Variant  value = 2;
}
message map_string_uint32 {
  optional string key = 1;
  optional uint32 value = 2;
}


